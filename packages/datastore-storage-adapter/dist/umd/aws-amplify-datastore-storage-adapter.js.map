{"version":3,"file":"aws-amplify-datastore-storage-adapter.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;;ACVA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;;;;;;;ACAwE;AACtB;;AAElD;AACA;AACA,0BAA0B,gFAAmB,KAAK,2DAAc;;AAE5B;AACpC;;;;;;;;;;;;;;;;;;ACRiD;AACC;AACA;;AAElD;AACA;AACA,mBAAmB,4DAAa;AAChC,sEAAoB;AACpB,IAAI,4DAAa;AACjB,IAAI,8DAAY;AAChB;AACA;;AAEA;AACA,mDAAmD;AACnD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qEAAmB;AAC/C,sBAAsB,0DAAO;AAC7B;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uEAAqB,GAAG,MAAM,0DAAO,uBAAuB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqC;AACrC;;;;;;;;;;;;;;;;;;ACnHkD;AACiF;AACiF;;AAEpN;AACA;AACA,QAAQ,uDAAuD,EAAE,yDAAK;AACtE,mBAAmB,4DAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0EAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA,2EAA2E,2BAA2B;AACtG,qBAAqB;AACrB,SAAS;AACT,yCAAyC,oEAAkB;AAC3D;AACA;AACA,+BAA+B,yEAAqB;AACpD,oBAAoB,kCAAkC;AACtD;AACA;AACA;AACA,oCAAoC,yCAAyC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD,oBAAoB,KAAK;AACzB,mEAAmE,oEAAkB;AACrF;AACA,6DAA6D,0DAAM,UAAU,0DAAM;AACnF;AACA,kBAAkB,sEAAoB;AACtC,kBAAkB,sEAAoB;AACtC,8CAA8C,0DAAM;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,WAAW;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA,wCAAwC,yEAAqB;AAC7D;AACA;AACA,YAAY,6EAAyB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mEAAiB;AAC9D;AACA,SAAS;AACT;AACA;AACA;AACA,yCAAyC,oEAAkB;AAC3D;AACA;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C;AACA,oCAAoC,sEAAc;AAClD;AACA;AACA,mDAAmD,4DAAQ;AAC3D,gBAAgB,kBAAkB;AAClC,yCAAyC,mEAAiB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC,4CAA4C,yEAAqB;AACjE,mCAAmC,mEAAiB;AACpD,oCAAoC,4EAA0B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA,iDAAiD,oEAAkB;AACnE;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA,mCAAmC,yEAAqB;AACxD,wBAAwB,kCAAkC;AAC1D;AACA;AACA;AACA,wCAAwC,yCAAyC;AACjF;AACA;AACA,wDAAwD,qEAAmB;AAC3E;AACA;AACA;AACA;AACA,kDAAkD,qEAAmB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC,oBAAoB,WAAW,0BAA0B,kCAAkC;AAC3F;AACA;AACA,wCAAwC,qEAAmB;AAC3D;AACA,mCAAmC,0DAAM;AACzC;AACA;AACA;AACA,uCAAuC,oEAAkB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,sEAAoB;AAC5D;AACA,+CAA+C,0DAAM;AACrD;AACA;AACA,wCAAwC,sEAAoB;AAC5D;AACA,+CAA+C,0DAAM;AACrD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAE+B;AAC/B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjPiL;;AAEjL;AACA;AACA,QAAQ,kDAAkD,EAAE,yDAAK;AACjE;AACA,kBAAkB,EAAE;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,4CAA4C,wEAAoB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,YAAY,2EAAmB;AAC/B;AACA;AACA;AACA,kCAAkC,WAAW,IAAI,0BAA0B;AAC3E;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA,YAAY,wEAAgB;AAC5B,kCAAkC,WAAW;AAC7C;AACA,gBAAgB,+EAAuB;AACvC;AACA;AACA;AACA;AACA;AACA,yCAAyC,6BAA6B,QAAQ,SAAS;AACvF;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA,8BAA8B,WAAW;AACzC;AACA;AACA;AACA,2BAA2B,YAAY;AACvC,KAAK;AACL;AACA,uBAAuB,WAAW;AAClC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,WAAW,KAAK,kBAAkB,EAAE;AACpG;AACA;AACA;AACA;AACA;AACA,4CAA4C,UAAU,KAAK,KAAK,YAAY,cAAc;AAC1F;AACA;AACA;AACA;AACA,uCAAuC,UAAU,QAAQ,eAAe;AACxE;AACA;AACA;AACA,8BAA8B,UAAU;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAM;AAC7B;AACA;AACA,uBAAuB,MAAM;AAC7B;AACA;AACA;AACA;AACA;AACA,6CAA6C,2BAA2B;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM,IAAI,oBAAoB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA,wBAAwB,MAAM,IAAI,iBAAiB,EAAE;AACrD;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,MAAM,QAAQ,gBAAgB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iBAAiB;AAClD;AACA;AACA,YAAY,wEAAgB;AAC5B,oBAAoB,+CAA+C;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,UAAU;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wBAAwB,GAAG,qBAAqB,YAAY,GAAG;AAClG;AACA,iBAAiB,sEAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,sBAAsB,SAAS,cAAc,IAAI,gCAAgC;AAC/H;AACA,iCAAiC,2BAA2B;AAC5D,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,UAAU;AAChD;AACA;AACA;AACA,yBAAyB,YAAY;AACrC;AACA;AACA;AACA,qBAAqB,cAAc;AACnC;AACA;AACA,yBAAyB,YAAY;AACrC;AACA;AACA;AACA;AACA;AACA,wBAAwB,4DAAQ;AAChC;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA;AACA,4CAA4C,UAAU;AACtD;AACA;AACA;AACA,oCAAoC,UAAU;AAC9C;AACA;AACA;AACA,yBAAyB,YAAY;AACrC;AACA;AACA;AACA;;AAEgX;AAChX;;;;;;;;;;;;;;;AC9UA;AACA;AACA;;AAEmB;AACnB;;;;;;;UCLA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;ACN6E;AAC7E","sources":["webpack:///webpack/universalModuleDefinition","webpack:///external umd \"@aws-amplify/core\"","webpack:///external umd \"@aws-amplify/datastore\"","webpack:///external umd \"react-native-sqlite-storage\"","webpack:///./dist/esm/SQLiteAdapter/SQLiteAdapter.mjs","webpack:///./dist/esm/SQLiteAdapter/SQLiteDatabase.mjs","webpack:///./dist/esm/common/CommonSQLiteAdapter.mjs","webpack:///./dist/esm/common/SQLiteUtils.mjs","webpack:///./dist/esm/common/constants.mjs","webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./dist/esm/index.mjs"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@aws-amplify/core\"), require(\"@aws-amplify/datastore\"), require(\"react-native-sqlite-storage\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"aws-amplify-datastore-storage-adapter\", [\"@aws-amplify/core\", \"@aws-amplify/datastore\", \"react-native-sqlite-storage\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"aws-amplify-datastore-storage-adapter\"] = factory(require(\"@aws-amplify/core\"), require(\"@aws-amplify/datastore\"), require(\"react-native-sqlite-storage\"));\n\telse\n\t\troot[\"aws-amplify-datastore-storage-adapter\"] = factory(root[\"@aws-amplify/core\"], root[\"@aws-amplify/datastore\"], root[\"react-native-sqlite-storage\"]);\n})(self, (__WEBPACK_EXTERNAL_MODULE__aws_amplify_core__, __WEBPACK_EXTERNAL_MODULE__aws_amplify_datastore__, __WEBPACK_EXTERNAL_MODULE_react_native_sqlite_storage__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__aws_amplify_core__;","module.exports = __WEBPACK_EXTERNAL_MODULE__aws_amplify_datastore__;","module.exports = __WEBPACK_EXTERNAL_MODULE_react_native_sqlite_storage__;","import { CommonSQLiteAdapter } from '../common/CommonSQLiteAdapter.mjs';\nimport SQLiteDatabase from './SQLiteDatabase.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst SQLiteAdapter = new CommonSQLiteAdapter(new SQLiteDatabase());\n\nexport { SQLiteAdapter as default };\n//# sourceMappingURL=SQLiteAdapter.mjs.map\n","import SQLite from 'react-native-sqlite-storage';\nimport { ConsoleLogger } from '@aws-amplify/core';\nimport { DB_NAME } from '../common/constants.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst logger = new ConsoleLogger('SQLiteDatabase');\nSQLite.enablePromise(true);\nif (ConsoleLogger.LOG_LEVEL === 'DEBUG') {\n    SQLite.DEBUG(true);\n}\n/*\n\nNote:\nI purposely avoided using arrow functions () => {} in this class,\nBecause I ran into issues with them in some of the SQLite method callbacks\n\nAlso, even though the SQLite library is promisified, certain operations\nonly work correctly with callbacks. Specifically, any time you need to\nget the result of an `executeSql` command inside of a transaction\n(see the batchQuery method below)\n\n*/\nclass SQLiteDatabase {\n    async init() {\n        // only open database once.\n        if (!this.db) {\n            this.db = await SQLite.openDatabase({\n                name: DB_NAME,\n                location: 'default',\n            });\n        }\n    }\n    async createSchema(statements) {\n        await this.executeStatements(statements);\n    }\n    async clear() {\n        await this.closeDB();\n        logger.debug('Deleting database');\n        await SQLite.deleteDatabase({ name: DB_NAME, location: 'default' });\n        logger.debug('Database deleted');\n    }\n    async get(statement, params) {\n        const results = await this.getAll(statement, params);\n        return results[0];\n    }\n    async getAll(statement, params) {\n        const [resultSet] = await this.db.executeSql(statement, params);\n        const result = resultSet &&\n            resultSet.rows &&\n            resultSet.rows.length &&\n            resultSet.rows.raw &&\n            resultSet.rows.raw();\n        return result || [];\n    }\n    async save(statement, params) {\n        await this.db.executeSql(statement, params);\n    }\n    async batchQuery(queryParameterizedStatements) {\n        const results = [];\n        await this.db.readTransaction(tx => {\n            for (const [statement, params] of queryParameterizedStatements) {\n                tx.executeSql(statement, params, (_, res) => {\n                    results.push(res.rows.raw()[0]);\n                }, logger.warn);\n            }\n        });\n        return results;\n    }\n    async batchSave(saveParameterizedStatements, deleteParameterizedStatements) {\n        await this.db.transaction(tx => {\n            for (const [statement, params] of saveParameterizedStatements) {\n                tx.executeSql(statement, params);\n            }\n        });\n        if (deleteParameterizedStatements) {\n            await this.db.transaction(tx => {\n                for (const [statement, params] of deleteParameterizedStatements) {\n                    tx.executeSql(statement, params);\n                }\n            });\n        }\n    }\n    async selectAndDelete(queryParameterizedStatement, deleteParameterizedStatement) {\n        let results = [];\n        const [queryStatement, queryParams] = queryParameterizedStatement;\n        const [deleteStatement, deleteParams] = deleteParameterizedStatement;\n        await this.db.transaction(tx => {\n            tx.executeSql(queryStatement, queryParams, (_, res) => {\n                results = res.rows.raw();\n            }, logger.warn);\n            tx.executeSql(deleteStatement, deleteParams, () => {\n                // no-op\n            }, logger.warn);\n        });\n        return results;\n    }\n    async executeStatements(statements) {\n        await this.db.transaction(tx => {\n            for (const statement of statements) {\n                tx.executeSql(statement);\n            }\n        });\n    }\n    async closeDB() {\n        if (this.db) {\n            logger.debug('Closing Database');\n            await this.db.close();\n            logger.debug('Database closed');\n            this.db = undefined;\n        }\n    }\n}\n\nexport { SQLiteDatabase as default };\n//# sourceMappingURL=SQLiteDatabase.mjs.map\n","import { ConsoleLogger } from '@aws-amplify/core';\nimport { ModelPredicateCreator, OpType, ModelSortPredicateCreator, isPredicateObj, QueryOne, utils } from '@aws-amplify/datastore';\nimport { generateSchemaStatements, queryByIdStatement, modelUpdateStatement, modelInsertStatement, queryAllStatement, queryOneStatement, deleteByPredicateStatement, deleteByIdStatement } from './SQLiteUtils.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst { traverseModel, validatePredicate, isModelConstructor } = utils;\nconst logger = new ConsoleLogger('DataStore');\nclass CommonSQLiteAdapter {\n    constructor(db) {\n        this.db = db;\n    }\n    async setUp(theSchema, namespaceResolver, modelInstanceCreator, getModelConstructorByModelName) {\n        if (!this.initPromise) {\n            this.initPromise = new Promise((_resolve, _reject) => {\n                this.resolve = _resolve;\n                this.reject = _reject;\n            });\n        }\n        else {\n            await this.initPromise;\n            return;\n        }\n        this.schema = theSchema;\n        this.namespaceResolver = namespaceResolver;\n        this.modelInstanceCreator = modelInstanceCreator;\n        this.getModelConstructorByModelName = getModelConstructorByModelName;\n        try {\n            const usesCPKCodegen = Object.values(this.schema.namespaces.user.models).some(model => Object.values(model.fields).some(field => \n            // eslint-disable-next-line no-prototype-builtins\n            field.association?.hasOwnProperty('targetNames')));\n            if (usesCPKCodegen) {\n                logger.error('The SQLite adapter does not support schemas using custom primary key. Set `graphQLTransformer.respectPrimaryKeyAttributesOnConnectionField in `amplify/cli.json` to false to disable custom primary key. To regenerate your API, add or remove an empty newline to your GraphQL schema (to change the computed hash) then run `amplify push`.');\n            }\n            await this.db.init();\n            const statements = generateSchemaStatements(this.schema);\n            await this.db.createSchema(statements);\n            this.resolve();\n        }\n        catch (error) {\n            this.reject(error);\n        }\n    }\n    async clear() {\n        await this.db.clear();\n        this.initPromise = undefined;\n    }\n    async save(model, condition) {\n        const modelConstructor = Object.getPrototypeOf(model)\n            .constructor;\n        const { name: tableName } = modelConstructor;\n        const connectedModels = traverseModel(modelConstructor.name, model, this.schema.namespaces[this.namespaceResolver(modelConstructor)], this.modelInstanceCreator, this.getModelConstructorByModelName);\n        const connectionStoreNames = Object.values(connectedModels).map(({ modelName, item, instance }) => {\n            return { modelName, item, instance };\n        });\n        const [queryStatement, params] = queryByIdStatement(model.id, tableName);\n        const fromDB = await this.db.get(queryStatement, params);\n        if (condition && fromDB) {\n            const predicates = ModelPredicateCreator.getPredicates(condition);\n            const { predicates: predicateObjs, type } = predicates;\n            const isValid = validatePredicate(fromDB, type, predicateObjs);\n            if (!isValid) {\n                const msg = 'Conditional update failed';\n                logger.error(msg, { model: fromDB, condition: predicateObjs });\n                throw new Error(msg);\n            }\n        }\n        const result = [];\n        const saveStatements = new Set();\n        for await (const resItem of connectionStoreNames) {\n            const { modelName, item, instance } = resItem;\n            const { id } = item;\n            const [queryStatementForRestItem, paramsForRestItem] = queryByIdStatement(id, modelName);\n            const fromDBForRestItem = await this.db.get(queryStatementForRestItem, paramsForRestItem);\n            const opType = fromDBForRestItem === undefined ? OpType.INSERT : OpType.UPDATE;\n            const saveStatement = fromDBForRestItem\n                ? modelUpdateStatement(instance, modelName)\n                : modelInsertStatement(instance, modelName);\n            if (id === model.id || opType === OpType.INSERT) {\n                saveStatements.add(saveStatement);\n                result.push([instance, opType]);\n            }\n        }\n        await this.db.batchSave(saveStatements);\n        return result;\n    }\n    async load(namespaceName, srcModelName, records) {\n        const namespace = this.schema.namespaces[namespaceName];\n        const relations = namespace.relationships[srcModelName].relationTypes;\n        const connectionTableNames = relations.map(({ modelName }) => modelName);\n        const modelConstructor = this.getModelConstructorByModelName(namespaceName, srcModelName);\n        if (connectionTableNames.length === 0) {\n            return records.map(record => this.modelInstanceCreator(modelConstructor, record));\n        }\n        // Remove related-model fields. They're all `null` in the database,\n        // and any that happen to be required will result in a false validation\n        // error when DataStore attempts to initialize with `null`.\n        // These fields aren't actually needed here. DataStore will use the FK's\n        // from the schema model.\n        return records.map(record => {\n            for (const r of relations) {\n                delete record[r.fieldName];\n            }\n            return this.modelInstanceCreator(modelConstructor, record);\n        });\n    }\n    async query(modelConstructor, predicate, pagination) {\n        const { name: tableName } = modelConstructor;\n        const namespaceName = this.namespaceResolver(modelConstructor);\n        const predicates = predicate && ModelPredicateCreator.getPredicates(predicate);\n        const sortPredicates = pagination &&\n            pagination.sort &&\n            ModelSortPredicateCreator.getPredicates(pagination.sort);\n        const limit = pagination && pagination.limit;\n        const page = limit && pagination.page;\n        const queryById = predicates && this.idFromPredicate(predicates);\n        const records = (await (async () => {\n            if (queryById) {\n                const record = await this.getById(tableName, queryById);\n                return record ? [record] : [];\n            }\n            const [queryStatement, params] = queryAllStatement(tableName, predicates, sortPredicates, limit, page);\n            return this.db.getAll(queryStatement, params);\n        })());\n        return this.load(namespaceName, modelConstructor.name, records);\n    }\n    async getById(tableName, id) {\n        const [queryStatement, params] = queryByIdStatement(id, tableName);\n        const record = await this.db.get(queryStatement, params);\n        return record;\n    }\n    idFromPredicate(predicates) {\n        const { predicates: predicateObjs } = predicates;\n        const idPredicate = predicateObjs.length === 1 &&\n            predicateObjs.find(p => isPredicateObj(p) && p.field === 'id' && p.operator === 'eq');\n        return idPredicate && idPredicate.operand;\n    }\n    async queryOne(modelConstructor, firstOrLast = QueryOne.FIRST) {\n        const { name: tableName } = modelConstructor;\n        const [queryStatement, params] = queryOneStatement(firstOrLast, tableName);\n        const result = await this.db.get(queryStatement, params);\n        const modelInstance = result && this.modelInstanceCreator(modelConstructor, result);\n        return modelInstance;\n    }\n    // Currently does not cascade\n    // TODO: use FKs in relations and have `ON DELETE CASCADE` set\n    // For Has Many and Has One relations to have SQL handle cascades automatically\n    async delete(modelOrModelConstructor, condition) {\n        if (isModelConstructor(modelOrModelConstructor)) {\n            const modelConstructor = modelOrModelConstructor;\n            const namespaceName = this.namespaceResolver(modelConstructor);\n            const { name: tableName } = modelConstructor;\n            const predicates = condition && ModelPredicateCreator.getPredicates(condition);\n            const queryStatement = queryAllStatement(tableName, predicates);\n            const deleteStatement = deleteByPredicateStatement(tableName, predicates);\n            const models = await this.db.selectAndDelete(queryStatement, deleteStatement);\n            const modelInstances = await this.load(namespaceName, modelConstructor.name, models);\n            return [modelInstances, modelInstances];\n        }\n        else {\n            const model = modelOrModelConstructor;\n            const modelConstructor = Object.getPrototypeOf(model)\n                .constructor;\n            const { name: tableName } = modelConstructor;\n            if (condition) {\n                const [queryStatement, params] = queryByIdStatement(model.id, tableName);\n                const fromDB = await this.db.get(queryStatement, params);\n                if (fromDB === undefined) {\n                    const msg = 'Model instance not found in storage';\n                    logger.warn(msg, { model });\n                    return [[model], []];\n                }\n                const predicates = ModelPredicateCreator.getPredicates(condition);\n                const { predicates: predicateObjs, type } = predicates;\n                const isValid = validatePredicate(fromDB, type, predicateObjs);\n                if (!isValid) {\n                    const msg = 'Conditional update failed';\n                    logger.error(msg, { model: fromDB, condition: predicateObjs });\n                    throw new Error(msg);\n                }\n                const [deleteStatement, deleteParams] = deleteByIdStatement(model.id, tableName);\n                await this.db.save(deleteStatement, deleteParams);\n                return [[model], [model]];\n            }\n            else {\n                const [deleteStatement, params] = deleteByIdStatement(model.id, tableName);\n                await this.db.save(deleteStatement, params);\n                return [[model], [model]];\n            }\n        }\n    }\n    async batchSave(modelConstructor, items) {\n        const { name: tableName } = modelConstructor;\n        const result = [];\n        const itemsToSave = [];\n        // To determine whether an item should result in an insert or update operation\n        // We first need to query the local DB on the item id\n        const queryStatements = new Set();\n        // Deletes don't need to be queried first, because if the item doesn't exist,\n        // the delete operation will be a no-op\n        const deleteStatements = new Set();\n        const saveStatements = new Set();\n        for (const item of items) {\n            const connectedModels = traverseModel(modelConstructor.name, this.modelInstanceCreator(modelConstructor, item), this.schema.namespaces[this.namespaceResolver(modelConstructor)], this.modelInstanceCreator, this.getModelConstructorByModelName);\n            const { id, _deleted } = item;\n            const { instance } = connectedModels.find(({ instance: connectedModelInstance }) => connectedModelInstance.id === id);\n            if (_deleted) {\n                // create the delete statements right away\n                const deleteStatement = deleteByIdStatement(instance.id, tableName);\n                deleteStatements.add(deleteStatement);\n                result.push([item, OpType.DELETE]);\n            }\n            else {\n                // query statements for the saves at first\n                const queryStatement = queryByIdStatement(id, tableName);\n                queryStatements.add(queryStatement);\n                // combination of insert and update items\n                itemsToSave.push(instance);\n            }\n        }\n        // returns the query results for each of the save items\n        const queryResponses = await this.db.batchQuery(queryStatements);\n        queryResponses.forEach((response, idx) => {\n            if (response === undefined) {\n                const insertStatement = modelInsertStatement(itemsToSave[idx], tableName);\n                saveStatements.add(insertStatement);\n                result.push([itemsToSave[idx], OpType.INSERT]);\n            }\n            else {\n                const updateStatement = modelUpdateStatement(itemsToSave[idx], tableName);\n                saveStatements.add(updateStatement);\n                result.push([itemsToSave[idx], OpType.UPDATE]);\n            }\n        });\n        // perform all of the insert/update/delete operations in a single transaction\n        await this.db.batchSave(saveStatements, deleteStatements);\n        return result;\n    }\n}\n\nexport { CommonSQLiteAdapter };\n//# sourceMappingURL=CommonSQLiteAdapter.mjs.map\n","import { isModelAttributeAuth, isGraphQLScalarType, isModelFieldType, isTargetNameAssociation, isPredicateGroup, isPredicateObj, QueryOne, utils } from '@aws-amplify/datastore';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst { USER, isNonModelConstructor, isModelConstructor } = utils;\nconst keysFromModel = model => Object.keys(model)\n    .map(k => `\"${k}\"`)\n    .join(', ');\nconst valuesFromModel = (model) => {\n    const values = Object.values(model).map(prepareValueForDML);\n    const paramaterized = values.map(() => '?').join(', ');\n    return [paramaterized, values];\n};\nconst updateSet = model => {\n    const values = [];\n    const paramaterized = Object.entries(model)\n        .filter(([k]) => k !== 'id')\n        .map(([k, v]) => {\n        values.push(prepareValueForDML(v));\n        return `\"${k}\"=?`;\n    })\n        .join(', ');\n    return [paramaterized, values];\n};\nfunction prepareValueForDML(value) {\n    const scalarTypes = ['string', 'number', 'boolean'];\n    const isScalarType = value === null || value === undefined || scalarTypes.includes(typeof value);\n    if (isScalarType) {\n        return value;\n    }\n    const isObjectType = typeof value === 'object' &&\n        (Object.getPrototypeOf(value).constructor === Object ||\n            isNonModelConstructor(Object.getPrototypeOf(value).constructor) ||\n            isModelConstructor(Object.getPrototypeOf(value).constructor));\n    if (Array.isArray(value) || isObjectType) {\n        return JSON.stringify(value);\n    }\n    return `${value}`;\n}\nfunction getSQLiteType(scalar) {\n    switch (scalar) {\n        case 'Boolean':\n        case 'Int':\n        case 'AWSTimestamp':\n            return 'INTEGER';\n        case 'ID':\n        case 'String':\n        case 'AWSDate':\n        case 'AWSTime':\n        case 'AWSDateTime':\n        case 'AWSEmail':\n        case 'AWSJSON':\n        case 'AWSURL':\n        case 'AWSPhone':\n        case 'AWSIPAddress':\n            return 'TEXT';\n        case 'Float':\n            return 'REAL';\n        default: {\n            throw new Error(`unknown type ${scalar}`);\n        }\n    }\n}\nfunction generateSchemaStatements(schema) {\n    return Object.keys(schema.namespaces).flatMap(namespaceName => {\n        const namespace = schema.namespaces[namespaceName];\n        const isUserModel = namespaceName === USER;\n        return Object.values(namespace.models).map(model => modelCreateTableStatement(model, isUserModel));\n    });\n}\nconst implicitAuthFieldsForModel = (model) => {\n    if (!model.attributes || !model.attributes.length) {\n        return [];\n    }\n    const authRules = model.attributes.find(isModelAttributeAuth);\n    if (!authRules) {\n        return [];\n    }\n    const authFieldsForModel = authRules.properties.rules\n        .filter((rule) => rule.ownerField || rule.groupsField)\n        .map((rule) => rule.ownerField || rule.groupsField);\n    return authFieldsForModel.filter((authField) => {\n        const authFieldExplicitlyDefined = Object.values(model.fields).find((f) => f.name === authField);\n        return !authFieldExplicitlyDefined;\n    });\n};\nfunction modelCreateTableStatement(model, userModel = false) {\n    // implicitly defined auth fields, e.g., `owner`, `groupsField`, etc.\n    const implicitAuthFields = implicitAuthFieldsForModel(model);\n    let fields = Object.values(model.fields).reduce((acc, field) => {\n        if (isGraphQLScalarType(field.type)) {\n            if (field.name === 'id') {\n                return [...acc, '\"id\" PRIMARY KEY NOT NULL'];\n            }\n            let columnParam = `\"${field.name}\" ${getSQLiteType(field.type)}`;\n            if (field.isRequired) {\n                columnParam += ' NOT NULL';\n            }\n            return [...acc, `${columnParam}`];\n        }\n        if (isModelFieldType(field.type)) {\n            let columnParam = `\"${field.name}\" TEXT`;\n            // add targetName as well as field name for BELONGS_TO relations\n            if (isTargetNameAssociation(field.association)) {\n                // check if this field has been explicitly defined in the model\n                const fkDefinedInModel = Object.values(model.fields).find((f) => f.name === field?.association?.targetName);\n                // if the FK is not explicitly defined in the model, we have to add it here\n                if (!fkDefinedInModel) {\n                    const required = field.isRequired ? ' NOT NULL' : '';\n                    columnParam += `, \"${field.association.targetName}\" TEXT${required}`;\n                }\n            }\n            // ignore isRequired param for model fields, since they will not contain\n            // the related data locally\n            return [...acc, `${columnParam}`];\n        }\n        // default to TEXT\n        let columnParam = `\"${field.name}\" TEXT`;\n        if (field.isRequired) {\n            columnParam += ' NOT NULL';\n        }\n        return [...acc, `${columnParam}`];\n    }, []);\n    implicitAuthFields.forEach((authField) => {\n        fields.push(`${authField} TEXT`);\n    });\n    if (userModel) {\n        fields = [\n            ...fields,\n            `\"_version\" INTEGER`,\n            `\"_lastChangedAt\" INTEGER`,\n            `\"_deleted\" INTEGER`,\n        ];\n    }\n    const createTableStatement = `CREATE TABLE IF NOT EXISTS \"${model.name}\" (${fields.join(', ')});`;\n    return createTableStatement;\n}\nfunction modelInsertStatement(model, tableName) {\n    const keys = keysFromModel(model);\n    const [paramaterized, values] = valuesFromModel(model);\n    const insertStatement = `INSERT INTO \"${tableName}\" (${keys}) VALUES (${paramaterized})`;\n    return [insertStatement, values];\n}\nfunction modelUpdateStatement(model, tableName) {\n    const [paramaterized, values] = updateSet(model);\n    const updateStatement = `UPDATE \"${tableName}\" SET ${paramaterized} WHERE id=?`;\n    return [updateStatement, [...values, model.id]];\n}\nfunction queryByIdStatement(id, tableName) {\n    return [`SELECT * FROM \"${tableName}\" WHERE \"id\" = ?`, [id]];\n}\n/*\n    Predicates supported by DataStore:\n\n    Strings: eq | ne | le | lt | ge | gt | contains | notContains | beginsWith | between\n    Numbers: eq | ne | le | lt | ge | gt | between\n    Lists: contains | notContains\n*/\nconst comparisonOperatorMap = {\n    eq: '=',\n    ne: '!=',\n    le: '<=',\n    lt: '<',\n    ge: '>=',\n    gt: '>',\n};\nconst logicalOperatorMap = {\n    beginsWith: '= 1',\n    contains: '> 0',\n    notContains: '= 0',\n    between: 'BETWEEN',\n};\n/**\n * If the given (operator, operand) indicate the need for a special `NULL` comparison,\n * that `WHERE` clause condition will be returned. If not special `NULL` handling is\n * needed, `null` will be returned, and the caller should construct the `WHERE`\n * clause component using the normal operator map(s) and parameterization.\n *\n * @param operator \"beginsWith\" | \"contains\" | \"notContains\" | \"between\"\n * | \"eq\" | \"ne\" | \"le\" | \"lt\" | \"ge\" | \"gt\"\n * @param operand any\n * @returns (string | null) The `WHERE` clause component or `null` if N/A.\n */\nfunction buildSpecialNullComparison(field, operator, operand) {\n    if (operand === null || operand === undefined) {\n        if (operator === 'eq') {\n            return `\"${field}\" IS NULL`;\n        }\n        else if (operator === 'ne') {\n            return `\"${field}\" IS NOT NULL`;\n        }\n    }\n    // no special null handling required\n    return null;\n}\nconst whereConditionFromPredicateObject = ({ field, operator, operand, }) => {\n    const specialNullClause = buildSpecialNullComparison(field, operator, operand);\n    if (specialNullClause) {\n        return [specialNullClause, []];\n    }\n    const comparisonOperator = comparisonOperatorMap[operator];\n    if (comparisonOperator) {\n        return [`\"${field}\" ${comparisonOperator} ?`, [operand]];\n    }\n    const logicalOperatorKey = operator;\n    const logicalOperator = logicalOperatorMap[logicalOperatorKey];\n    let statement;\n    if (logicalOperator) {\n        let rightExp = [];\n        switch (logicalOperatorKey) {\n            case 'between':\n                rightExp = operand; // operand is a 2-tuple\n                statement = [\n                    `\"${field}\" ${logicalOperator} ${rightExp\n                        .map(_ => '?')\n                        .join(' AND ')}`,\n                    rightExp,\n                ];\n                break;\n            case 'beginsWith':\n            case 'contains':\n            case 'notContains':\n                statement = [`instr(\"${field}\", ?) ${logicalOperator}`, [operand]];\n                break;\n            default: {\n                // Incorrect WHERE clause can result in data loss\n                throw new Error('Cannot map predicate to a valid WHERE clause');\n            }\n        }\n        return statement;\n    }\n};\nfunction whereClauseFromPredicate(predicate) {\n    const result = [];\n    const params = [];\n    recurse(predicate, result, params);\n    const whereClause = `WHERE ${result.join(' ')}`;\n    return [whereClause, params];\n    function recurse(recursedPredicate, recursedResult = [], recursedParams = []) {\n        if (isPredicateGroup(recursedPredicate)) {\n            const { type: groupType, predicates: groupPredicates } = recursedPredicate;\n            let filterType = '';\n            let isNegation = false;\n            switch (groupType) {\n                case 'not':\n                    isNegation = true;\n                    break;\n                case 'and':\n                    filterType = 'AND';\n                    break;\n                case 'or':\n                    filterType = 'OR';\n                    break;\n                default: {\n                    throw new Error(`Invalid ${groupType}`);\n                }\n            }\n            const groupResult = [];\n            for (const p of groupPredicates) {\n                recurse(p, groupResult, recursedParams);\n            }\n            recursedResult.push(`${isNegation ? 'NOT' : ''}(${groupResult.join(` ${filterType} `)})`);\n        }\n        else if (isPredicateObj(recursedPredicate)) {\n            const [condition, conditionParams] = whereConditionFromPredicateObject(recursedPredicate);\n            recursedResult.push(condition);\n            recursedParams.push(...conditionParams);\n        }\n    }\n}\nconst sortDirectionMap = {\n    ASCENDING: 'ASC',\n    DESCENDING: 'DESC',\n};\nfunction orderByClauseFromSort(sortPredicate = []) {\n    const orderByParts = sortPredicate.map(({ field, sortDirection }) => `\"${String(field)}\" ${sortDirectionMap[sortDirection]}`);\n    // We always sort by _rowid_ last\n    orderByParts.push(`_rowid_ ${sortDirectionMap.ASCENDING}`);\n    return `ORDER BY ${orderByParts.join(', ')}`;\n}\nfunction limitClauseFromPagination(limit, page = 0) {\n    const params = [limit];\n    let clause = 'LIMIT ?';\n    if (page) {\n        const offset = limit * page;\n        params.push(offset);\n        clause += ' OFFSET ?';\n    }\n    return [clause, params];\n}\nfunction queryAllStatement(tableName, predicate, sort, limit, page) {\n    let statement = `SELECT * FROM \"${tableName}\"`;\n    const params = [];\n    if (predicate && predicate.predicates.length) {\n        const [whereClause, whereParams] = whereClauseFromPredicate(predicate);\n        statement += ` ${whereClause}`;\n        params.push(...whereParams);\n    }\n    const orderByClause = orderByClauseFromSort(sort);\n    statement += ` ${orderByClause}`;\n    if (limit) {\n        const [limitClause, limitParams] = limitClauseFromPagination(limit, page);\n        statement += ` ${limitClause}`;\n        params.push(...limitParams);\n    }\n    return [statement, params];\n}\nfunction queryOneStatement(firstOrLast, tableName) {\n    if (firstOrLast === QueryOne.FIRST) {\n        // ORDER BY rowid will no longer work as expected if a customer has\n        // a field by that name in their schema. We may want to enforce it\n        // as a reserved keyword in Codegen\n        return [`SELECT * FROM ${tableName} ORDER BY _rowid_ LIMIT 1`, []];\n    }\n    else {\n        return [`SELECT * FROM ${tableName} ORDER BY _rowid_ DESC LIMIT 1`, []];\n    }\n}\nfunction deleteByIdStatement(id, tableName) {\n    const deleteStatement = `DELETE FROM \"${tableName}\" WHERE \"id\"=?`;\n    return [deleteStatement, [id]];\n}\nfunction deleteByPredicateStatement(tableName, predicate) {\n    let statement = `DELETE FROM \"${tableName}\"`;\n    const params = [];\n    if (predicate && predicate.predicates.length) {\n        const [whereClause, whereParams] = whereClauseFromPredicate(predicate);\n        statement += ` ${whereClause}`;\n        params.push(...whereParams);\n    }\n    return [statement, params];\n}\n\nexport { deleteByIdStatement, deleteByPredicateStatement, generateSchemaStatements, getSQLiteType, implicitAuthFieldsForModel, limitClauseFromPagination, modelCreateTableStatement, modelInsertStatement, modelUpdateStatement, orderByClauseFromSort, queryAllStatement, queryByIdStatement, queryOneStatement, whereClauseFromPredicate, whereConditionFromPredicateObject };\n//# sourceMappingURL=SQLiteUtils.mjs.map\n","// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst DB_NAME = 'AmplifyDatastore';\n\nexport { DB_NAME };\n//# sourceMappingURL=constants.mjs.map\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export { default as SQLiteAdapter } from './SQLiteAdapter/SQLiteAdapter.mjs';\n//# sourceMappingURL=index.mjs.map\n"],"names":[],"sourceRoot":""}