!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("@aws-amplify/core"),require("@aws-amplify/datastore"),require("react-native-sqlite-storage")):"function"==typeof define&&define.amd?define("aws-amplify-datastore-storage-adapter",["@aws-amplify/core","@aws-amplify/datastore","react-native-sqlite-storage"],t):"object"==typeof exports?exports["aws-amplify-datastore-storage-adapter"]=t(require("@aws-amplify/core"),require("@aws-amplify/datastore"),require("react-native-sqlite-storage")):e["aws-amplify-datastore-storage-adapter"]=t(e["@aws-amplify/core"],e["@aws-amplify/datastore"],e["react-native-sqlite-storage"])}(self,((e,t,a)=>(()=>{"use strict";var s={374:t=>{t.exports=e},74:e=>{e.exports=t},152:e=>{e.exports=a}},r={};function n(e){var t=r[e];if(void 0!==t)return t.exports;var a=r[e]={exports:{}};return s[e](a,a.exports,n),a.exports}n.d=(e,t)=>{for(var a in t)n.o(t,a)&&!n.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:t[a]})},n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var o={};n.r(o),n.d(o,{SQLiteAdapter:()=>I});var i=n(374),c=n(74);const{USER:d,isNonModelConstructor:l,isModelConstructor:u}=c.utils;function p(e){if(null==e||["string","number","boolean"].includes(typeof e))return e;const t="object"==typeof e&&(Object.getPrototypeOf(e).constructor===Object||l(Object.getPrototypeOf(e).constructor)||u(Object.getPrototypeOf(e).constructor));return Array.isArray(e)||t?JSON.stringify(e):`${e}`}const m=e=>{if(!e.attributes||!e.attributes.length)return[];const t=e.attributes.find(c.isModelAttributeAuth);return t?t.properties.rules.filter((e=>e.ownerField||e.groupsField)).map((e=>e.ownerField||e.groupsField)).filter((t=>!Object.values(e.fields).find((e=>e.name===t)))):[]};function h(e,t){const a=(e=>Object.keys(e).map((e=>`"${e}"`)).join(", "))(e),[s,r]=(e=>{const t=Object.values(e).map(p);return[t.map((()=>"?")).join(", "),t]})(e);return[`INSERT INTO "${t}" (${a}) VALUES (${s})`,r]}function f(e,t){const[a,s]=(e=>{const t=[];return[Object.entries(e).filter((([e])=>"id"!==e)).map((([e,a])=>(t.push(p(a)),`"${e}"=?`))).join(", "),t]})(e);return[`UPDATE "${t}" SET ${a} WHERE id=?`,[...s,e.id]]}function y(e,t){return[`SELECT * FROM "${t}" WHERE "id" = ?`,[e]]}const b={eq:"=",ne:"!=",le:"<=",lt:"<",ge:">=",gt:">"},w={beginsWith:"= 1",contains:"> 0",notContains:"= 0",between:"BETWEEN"};function E(e){const t=[],a=[];return function e(t,a=[],s=[]){if((0,c.isPredicateGroup)(t)){const{type:r,predicates:n}=t;let o="",i=!1;switch(r){case"not":i=!0;break;case"and":o="AND";break;case"or":o="OR";break;default:throw new Error(`Invalid ${r}`)}const c=[];for(const t of n)e(t,c,s);a.push(`${i?"NOT":""}(${c.join(` ${o} `)})`)}else if((0,c.isPredicateObj)(t)){const[e,r]=(({field:e,operator:t,operand:a})=>{const s=function(e,t,a){if(null==a){if("eq"===t)return`"${e}" IS NULL`;if("ne"===t)return`"${e}" IS NOT NULL`}return null}(e,t,a);if(s)return[s,[]];const r=b[t];if(r)return[`"${e}" ${r} ?`,[a]];const n=w[t];let o;if(n){let s=[];switch(t){case"between":s=a,o=[`"${e}" ${n} ${s.map((e=>"?")).join(" AND ")}`,s];break;case"beginsWith":case"contains":case"notContains":o=[`instr("${e}", ?) ${n}`,[a]];break;default:throw new Error("Cannot map predicate to a valid WHERE clause")}return o}})(t);a.push(e),s.push(...r)}}(e,t,a),[`WHERE ${t.join(" ")}`,a]}const g={ASCENDING:"ASC",DESCENDING:"DESC"};function S(e,t,a,s,r){let n=`SELECT * FROM "${e}"`;const o=[];if(t&&t.predicates.length){const[e,a]=E(t);n+=` ${e}`,o.push(...a)}if(n+=` ${function(e=[]){const t=e.map((({field:e,sortDirection:t})=>`"${String(e)}" ${g[t]}`));return t.push(`_rowid_ ${g.ASCENDING}`),`ORDER BY ${t.join(", ")}`}(a)}`,s){const[e,t]=function(e,t=0){const a=[e];let s="LIMIT ?";if(t){const r=e*t;a.push(r),s+=" OFFSET ?"}return[s,a]}(s,r);n+=` ${e}`,o.push(...t)}return[n,o]}function T(e,t){return[`DELETE FROM "${t}" WHERE "id"=?`,[e]]}const{traverseModel:O,validatePredicate:v,isModelConstructor:$}=c.utils,N=new i.ConsoleLogger("DataStore");var R=n(152);const C="AmplifyDatastore",P=new i.ConsoleLogger("SQLiteDatabase");R.enablePromise(!0),"DEBUG"===i.ConsoleLogger.LOG_LEVEL&&R.DEBUG(!0);const I=new class{constructor(e){this.db=e}async setUp(e,t,a,s){if(this.initPromise)await this.initPromise;else{this.initPromise=new Promise(((e,t)=>{this.resolve=e,this.reject=t})),this.schema=e,this.namespaceResolver=t,this.modelInstanceCreator=a,this.getModelConstructorByModelName=s;try{Object.values(this.schema.namespaces.user.models).some((e=>Object.values(e.fields).some((e=>e.association?.hasOwnProperty("targetNames")))))&&N.error("The SQLite adapter does not support schemas using custom primary key. Set `graphQLTransformer.respectPrimaryKeyAttributesOnConnectionField in `amplify/cli.json` to false to disable custom primary key. To regenerate your API, add or remove an empty newline to your GraphQL schema (to change the computed hash) then run `amplify push`."),await this.db.init();const e=(r=this.schema,Object.keys(r.namespaces).flatMap((e=>{const t=r.namespaces[e],a=e===d;return Object.values(t.models).map((e=>function(e,t=!1){const a=m(e);let s=Object.values(e.fields).reduce(((t,a)=>{if((0,c.isGraphQLScalarType)(a.type)){if("id"===a.name)return[...t,'"id" PRIMARY KEY NOT NULL'];let e=`"${a.name}" ${function(e){switch(e){case"Boolean":case"Int":case"AWSTimestamp":return"INTEGER";case"ID":case"String":case"AWSDate":case"AWSTime":case"AWSDateTime":case"AWSEmail":case"AWSJSON":case"AWSURL":case"AWSPhone":case"AWSIPAddress":return"TEXT";case"Float":return"REAL";default:throw new Error(`unknown type ${e}`)}}(a.type)}`;return a.isRequired&&(e+=" NOT NULL"),[...t,`${e}`]}if((0,c.isModelFieldType)(a.type)){let s=`"${a.name}" TEXT`;if((0,c.isTargetNameAssociation)(a.association)&&!Object.values(e.fields).find((e=>e.name===a?.association?.targetName))){const e=a.isRequired?" NOT NULL":"";s+=`, "${a.association.targetName}" TEXT${e}`}return[...t,`${s}`]}let s=`"${a.name}" TEXT`;return a.isRequired&&(s+=" NOT NULL"),[...t,`${s}`]}),[]);return a.forEach((e=>{s.push(`${e} TEXT`)})),t&&(s=[...s,'"_version" INTEGER','"_lastChangedAt" INTEGER','"_deleted" INTEGER']),`CREATE TABLE IF NOT EXISTS "${e.name}" (${s.join(", ")});`}(e,a)))})));await this.db.createSchema(e),this.resolve()}catch(e){this.reject(e)}}var r}async clear(){await this.db.clear(),this.initPromise=void 0}async save(e,t){const a=Object.getPrototypeOf(e).constructor,{name:s}=a,r=O(a.name,e,this.schema.namespaces[this.namespaceResolver(a)],this.modelInstanceCreator,this.getModelConstructorByModelName),n=Object.values(r).map((({modelName:e,item:t,instance:a})=>({modelName:e,item:t,instance:a}))),[o,i]=y(e.id,s),d=await this.db.get(o,i);if(t&&d){const e=c.ModelPredicateCreator.getPredicates(t),{predicates:a,type:s}=e;if(!v(d,s,a)){const e="Conditional update failed";throw N.error(e,{model:d,condition:a}),new Error(e)}}const l=[],u=new Set;for await(const t of n){const{modelName:a,item:s,instance:r}=t,{id:n}=s,[o,i]=y(n,a),d=await this.db.get(o,i),p=void 0===d?c.OpType.INSERT:c.OpType.UPDATE,m=d?f(r,a):h(r,a);n!==e.id&&p!==c.OpType.INSERT||(u.add(m),l.push([r,p]))}return await this.db.batchSave(u),l}async load(e,t,a){const s=this.schema.namespaces[e].relationships[t].relationTypes,r=s.map((({modelName:e})=>e)),n=this.getModelConstructorByModelName(e,t);return 0===r.length?a.map((e=>this.modelInstanceCreator(n,e))):a.map((e=>{for(const t of s)delete e[t.fieldName];return this.modelInstanceCreator(n,e)}))}async query(e,t,a){const{name:s}=e,r=this.namespaceResolver(e),n=t&&c.ModelPredicateCreator.getPredicates(t),o=a&&a.sort&&c.ModelSortPredicateCreator.getPredicates(a.sort),i=a&&a.limit,d=i&&a.page,l=n&&this.idFromPredicate(n),u=await(async()=>{if(l){const e=await this.getById(s,l);return e?[e]:[]}const[e,t]=S(s,n,o,i,d);return this.db.getAll(e,t)})();return this.load(r,e.name,u)}async getById(e,t){const[a,s]=y(t,e);return await this.db.get(a,s)}idFromPredicate(e){const{predicates:t}=e,a=1===t.length&&t.find((e=>(0,c.isPredicateObj)(e)&&"id"===e.field&&"eq"===e.operator));return a&&a.operand}async queryOne(e,t=c.QueryOne.FIRST){const{name:a}=e,[s,r]=function(e,t){return e===c.QueryOne.FIRST?[`SELECT * FROM ${t} ORDER BY _rowid_ LIMIT 1`,[]]:[`SELECT * FROM ${t} ORDER BY _rowid_ DESC LIMIT 1`,[]]}(t,a),n=await this.db.get(s,r);return n&&this.modelInstanceCreator(e,n)}async delete(e,t){if($(e)){const a=e,s=this.namespaceResolver(a),{name:r}=a,n=t&&c.ModelPredicateCreator.getPredicates(t),o=S(r,n),i=function(e,t){let a=`DELETE FROM "${e}"`;const s=[];if(t&&t.predicates.length){const[e,r]=E(t);a+=` ${e}`,s.push(...r)}return[a,s]}(r,n),d=await this.db.selectAndDelete(o,i),l=await this.load(s,a.name,d);return[l,l]}{const a=e,s=Object.getPrototypeOf(a).constructor,{name:r}=s;if(t){const[e,s]=y(a.id,r),n=await this.db.get(e,s);if(void 0===n){const e="Model instance not found in storage";return N.warn(e,{model:a}),[[a],[]]}const o=c.ModelPredicateCreator.getPredicates(t),{predicates:i,type:d}=o;if(!v(n,d,i)){const e="Conditional update failed";throw N.error(e,{model:n,condition:i}),new Error(e)}const[l,u]=T(a.id,r);return await this.db.save(l,u),[[a],[a]]}{const[e,t]=T(a.id,r);return await this.db.save(e,t),[[a],[a]]}}}async batchSave(e,t){const{name:a}=e,s=[],r=[],n=new Set,o=new Set,i=new Set;for(const i of t){const t=O(e.name,this.modelInstanceCreator(e,i),this.schema.namespaces[this.namespaceResolver(e)],this.modelInstanceCreator,this.getModelConstructorByModelName),{id:d,_deleted:l}=i,{instance:u}=t.find((({instance:e})=>e.id===d));if(l){const e=T(u.id,a);o.add(e),s.push([i,c.OpType.DELETE])}else{const e=y(d,a);n.add(e),r.push(u)}}return(await this.db.batchQuery(n)).forEach(((e,t)=>{if(void 0===e){const e=h(r[t],a);i.add(e),s.push([r[t],c.OpType.INSERT])}else{const e=f(r[t],a);i.add(e),s.push([r[t],c.OpType.UPDATE])}})),await this.db.batchSave(i,o),s}}(new class{async init(){this.db||(this.db=await R.openDatabase({name:C,location:"default"}))}async createSchema(e){await this.executeStatements(e)}async clear(){await this.closeDB(),P.debug("Deleting database"),await R.deleteDatabase({name:C,location:"default"}),P.debug("Database deleted")}async get(e,t){return(await this.getAll(e,t))[0]}async getAll(e,t){const[a]=await this.db.executeSql(e,t);return a&&a.rows&&a.rows.length&&a.rows.raw&&a.rows.raw()||[]}async save(e,t){await this.db.executeSql(e,t)}async batchQuery(e){const t=[];return await this.db.readTransaction((a=>{for(const[s,r]of e)a.executeSql(s,r,((e,a)=>{t.push(a.rows.raw()[0])}),P.warn)})),t}async batchSave(e,t){await this.db.transaction((t=>{for(const[a,s]of e)t.executeSql(a,s)})),t&&await this.db.transaction((e=>{for(const[a,s]of t)e.executeSql(a,s)}))}async selectAndDelete(e,t){let a=[];const[s,r]=e,[n,o]=t;return await this.db.transaction((e=>{e.executeSql(s,r,((e,t)=>{a=t.rows.raw()}),P.warn),e.executeSql(n,o,(()=>{}),P.warn)})),a}async executeStatements(e){await this.db.transaction((t=>{for(const a of e)t.executeSql(a)}))}async closeDB(){this.db&&(P.debug("Closing Database"),await this.db.close(),P.debug("Database closed"),this.db=void 0)}});return o})()));
//# sourceMappingURL=aws-amplify-datastore-storage-adapter.min.js.map