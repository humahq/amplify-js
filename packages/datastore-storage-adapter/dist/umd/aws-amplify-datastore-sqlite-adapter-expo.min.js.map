{"version":3,"file":"aws-amplify-datastore-sqlite-adapter-expo.min.js","mappings":"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","sources":["webpack:///webpack/universalModuleDefinition","webpack:///external umd \"@aws-amplify/core\"","webpack:///external umd \"@aws-amplify/datastore\"","webpack:///external umd \"expo-file-system\"","webpack:///external umd \"expo-sqlite\"","webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./dist/esm/common/SQLiteUtils.mjs","webpack:///./dist/esm/common/CommonSQLiteAdapter.mjs","webpack:///./dist/esm/common/constants.mjs","webpack:///./dist/esm/ExpoSQLiteAdapter/ExpoSQLiteDatabase.mjs","webpack:///./dist/esm/ExpoSQLiteAdapter/ExpoSQLiteAdapter.mjs"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@aws-amplify/core\"), require(\"@aws-amplify/datastore\"), require(\"expo-file-system\"), require(\"expo-sqlite\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"aws-amplify-datastore-storage-adapter\", [\"@aws-amplify/core\", \"@aws-amplify/datastore\", \"expo-file-system\", \"expo-sqlite\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"aws-amplify-datastore-storage-adapter\"] = factory(require(\"@aws-amplify/core\"), require(\"@aws-amplify/datastore\"), require(\"expo-file-system\"), require(\"expo-sqlite\"));\n\telse\n\t\troot[\"aws-amplify-datastore-storage-adapter\"] = factory(root[\"@aws-amplify/core\"], root[\"@aws-amplify/datastore\"], root[\"expo-file-system\"], root[\"expo-sqlite\"]);\n})(self, (__WEBPACK_EXTERNAL_MODULE__374__, __WEBPACK_EXTERNAL_MODULE__74__, __WEBPACK_EXTERNAL_MODULE__889__, __WEBPACK_EXTERNAL_MODULE__287__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__374__;","module.exports = __WEBPACK_EXTERNAL_MODULE__74__;","module.exports = __WEBPACK_EXTERNAL_MODULE__889__;","module.exports = __WEBPACK_EXTERNAL_MODULE__287__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { isModelAttributeAuth, isGraphQLScalarType, isModelFieldType, isTargetNameAssociation, isPredicateGroup, isPredicateObj, QueryOne, utils } from '@aws-amplify/datastore';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst { USER, isNonModelConstructor, isModelConstructor } = utils;\nconst keysFromModel = model => Object.keys(model)\n    .map(k => `\"${k}\"`)\n    .join(', ');\nconst valuesFromModel = (model) => {\n    const values = Object.values(model).map(prepareValueForDML);\n    const paramaterized = values.map(() => '?').join(', ');\n    return [paramaterized, values];\n};\nconst updateSet = model => {\n    const values = [];\n    const paramaterized = Object.entries(model)\n        .filter(([k]) => k !== 'id')\n        .map(([k, v]) => {\n        values.push(prepareValueForDML(v));\n        return `\"${k}\"=?`;\n    })\n        .join(', ');\n    return [paramaterized, values];\n};\nfunction prepareValueForDML(value) {\n    const scalarTypes = ['string', 'number', 'boolean'];\n    const isScalarType = value === null || value === undefined || scalarTypes.includes(typeof value);\n    if (isScalarType) {\n        return value;\n    }\n    const isObjectType = typeof value === 'object' &&\n        (Object.getPrototypeOf(value).constructor === Object ||\n            isNonModelConstructor(Object.getPrototypeOf(value).constructor) ||\n            isModelConstructor(Object.getPrototypeOf(value).constructor));\n    if (Array.isArray(value) || isObjectType) {\n        return JSON.stringify(value);\n    }\n    return `${value}`;\n}\nfunction getSQLiteType(scalar) {\n    switch (scalar) {\n        case 'Boolean':\n        case 'Int':\n        case 'AWSTimestamp':\n            return 'INTEGER';\n        case 'ID':\n        case 'String':\n        case 'AWSDate':\n        case 'AWSTime':\n        case 'AWSDateTime':\n        case 'AWSEmail':\n        case 'AWSJSON':\n        case 'AWSURL':\n        case 'AWSPhone':\n        case 'AWSIPAddress':\n            return 'TEXT';\n        case 'Float':\n            return 'REAL';\n        default: {\n            throw new Error(`unknown type ${scalar}`);\n        }\n    }\n}\nfunction generateSchemaStatements(schema) {\n    return Object.keys(schema.namespaces).flatMap(namespaceName => {\n        const namespace = schema.namespaces[namespaceName];\n        const isUserModel = namespaceName === USER;\n        return Object.values(namespace.models).map(model => modelCreateTableStatement(model, isUserModel));\n    });\n}\nconst implicitAuthFieldsForModel = (model) => {\n    if (!model.attributes || !model.attributes.length) {\n        return [];\n    }\n    const authRules = model.attributes.find(isModelAttributeAuth);\n    if (!authRules) {\n        return [];\n    }\n    const authFieldsForModel = authRules.properties.rules\n        .filter((rule) => rule.ownerField || rule.groupsField)\n        .map((rule) => rule.ownerField || rule.groupsField);\n    return authFieldsForModel.filter((authField) => {\n        const authFieldExplicitlyDefined = Object.values(model.fields).find((f) => f.name === authField);\n        return !authFieldExplicitlyDefined;\n    });\n};\nfunction modelCreateTableStatement(model, userModel = false) {\n    // implicitly defined auth fields, e.g., `owner`, `groupsField`, etc.\n    const implicitAuthFields = implicitAuthFieldsForModel(model);\n    let fields = Object.values(model.fields).reduce((acc, field) => {\n        if (isGraphQLScalarType(field.type)) {\n            if (field.name === 'id') {\n                return [...acc, '\"id\" PRIMARY KEY NOT NULL'];\n            }\n            let columnParam = `\"${field.name}\" ${getSQLiteType(field.type)}`;\n            if (field.isRequired) {\n                columnParam += ' NOT NULL';\n            }\n            return [...acc, `${columnParam}`];\n        }\n        if (isModelFieldType(field.type)) {\n            let columnParam = `\"${field.name}\" TEXT`;\n            // add targetName as well as field name for BELONGS_TO relations\n            if (isTargetNameAssociation(field.association)) {\n                // check if this field has been explicitly defined in the model\n                const fkDefinedInModel = Object.values(model.fields).find((f) => f.name === field?.association?.targetName);\n                // if the FK is not explicitly defined in the model, we have to add it here\n                if (!fkDefinedInModel) {\n                    const required = field.isRequired ? ' NOT NULL' : '';\n                    columnParam += `, \"${field.association.targetName}\" TEXT${required}`;\n                }\n            }\n            // ignore isRequired param for model fields, since they will not contain\n            // the related data locally\n            return [...acc, `${columnParam}`];\n        }\n        // default to TEXT\n        let columnParam = `\"${field.name}\" TEXT`;\n        if (field.isRequired) {\n            columnParam += ' NOT NULL';\n        }\n        return [...acc, `${columnParam}`];\n    }, []);\n    implicitAuthFields.forEach((authField) => {\n        fields.push(`${authField} TEXT`);\n    });\n    if (userModel) {\n        fields = [\n            ...fields,\n            `\"_version\" INTEGER`,\n            `\"_lastChangedAt\" INTEGER`,\n            `\"_deleted\" INTEGER`,\n        ];\n    }\n    const createTableStatement = `CREATE TABLE IF NOT EXISTS \"${model.name}\" (${fields.join(', ')});`;\n    return createTableStatement;\n}\nfunction modelInsertStatement(model, tableName) {\n    const keys = keysFromModel(model);\n    const [paramaterized, values] = valuesFromModel(model);\n    const insertStatement = `INSERT INTO \"${tableName}\" (${keys}) VALUES (${paramaterized})`;\n    return [insertStatement, values];\n}\nfunction modelUpdateStatement(model, tableName) {\n    const [paramaterized, values] = updateSet(model);\n    const updateStatement = `UPDATE \"${tableName}\" SET ${paramaterized} WHERE id=?`;\n    return [updateStatement, [...values, model.id]];\n}\nfunction queryByIdStatement(id, tableName) {\n    return [`SELECT * FROM \"${tableName}\" WHERE \"id\" = ?`, [id]];\n}\n/*\n    Predicates supported by DataStore:\n\n    Strings: eq | ne | le | lt | ge | gt | contains | notContains | beginsWith | between\n    Numbers: eq | ne | le | lt | ge | gt | between\n    Lists: contains | notContains\n*/\nconst comparisonOperatorMap = {\n    eq: '=',\n    ne: '!=',\n    le: '<=',\n    lt: '<',\n    ge: '>=',\n    gt: '>',\n};\nconst logicalOperatorMap = {\n    beginsWith: '= 1',\n    contains: '> 0',\n    notContains: '= 0',\n    between: 'BETWEEN',\n};\n/**\n * If the given (operator, operand) indicate the need for a special `NULL` comparison,\n * that `WHERE` clause condition will be returned. If not special `NULL` handling is\n * needed, `null` will be returned, and the caller should construct the `WHERE`\n * clause component using the normal operator map(s) and parameterization.\n *\n * @param operator \"beginsWith\" | \"contains\" | \"notContains\" | \"between\"\n * | \"eq\" | \"ne\" | \"le\" | \"lt\" | \"ge\" | \"gt\"\n * @param operand any\n * @returns (string | null) The `WHERE` clause component or `null` if N/A.\n */\nfunction buildSpecialNullComparison(field, operator, operand) {\n    if (operand === null || operand === undefined) {\n        if (operator === 'eq') {\n            return `\"${field}\" IS NULL`;\n        }\n        else if (operator === 'ne') {\n            return `\"${field}\" IS NOT NULL`;\n        }\n    }\n    // no special null handling required\n    return null;\n}\nconst whereConditionFromPredicateObject = ({ field, operator, operand, }) => {\n    const specialNullClause = buildSpecialNullComparison(field, operator, operand);\n    if (specialNullClause) {\n        return [specialNullClause, []];\n    }\n    const comparisonOperator = comparisonOperatorMap[operator];\n    if (comparisonOperator) {\n        return [`\"${field}\" ${comparisonOperator} ?`, [operand]];\n    }\n    const logicalOperatorKey = operator;\n    const logicalOperator = logicalOperatorMap[logicalOperatorKey];\n    let statement;\n    if (logicalOperator) {\n        let rightExp = [];\n        switch (logicalOperatorKey) {\n            case 'between':\n                rightExp = operand; // operand is a 2-tuple\n                statement = [\n                    `\"${field}\" ${logicalOperator} ${rightExp\n                        .map(_ => '?')\n                        .join(' AND ')}`,\n                    rightExp,\n                ];\n                break;\n            case 'beginsWith':\n            case 'contains':\n            case 'notContains':\n                statement = [`instr(\"${field}\", ?) ${logicalOperator}`, [operand]];\n                break;\n            default: {\n                // Incorrect WHERE clause can result in data loss\n                throw new Error('Cannot map predicate to a valid WHERE clause');\n            }\n        }\n        return statement;\n    }\n};\nfunction whereClauseFromPredicate(predicate) {\n    const result = [];\n    const params = [];\n    recurse(predicate, result, params);\n    const whereClause = `WHERE ${result.join(' ')}`;\n    return [whereClause, params];\n    function recurse(recursedPredicate, recursedResult = [], recursedParams = []) {\n        if (isPredicateGroup(recursedPredicate)) {\n            const { type: groupType, predicates: groupPredicates } = recursedPredicate;\n            let filterType = '';\n            let isNegation = false;\n            switch (groupType) {\n                case 'not':\n                    isNegation = true;\n                    break;\n                case 'and':\n                    filterType = 'AND';\n                    break;\n                case 'or':\n                    filterType = 'OR';\n                    break;\n                default: {\n                    throw new Error(`Invalid ${groupType}`);\n                }\n            }\n            const groupResult = [];\n            for (const p of groupPredicates) {\n                recurse(p, groupResult, recursedParams);\n            }\n            recursedResult.push(`${isNegation ? 'NOT' : ''}(${groupResult.join(` ${filterType} `)})`);\n        }\n        else if (isPredicateObj(recursedPredicate)) {\n            const [condition, conditionParams] = whereConditionFromPredicateObject(recursedPredicate);\n            recursedResult.push(condition);\n            recursedParams.push(...conditionParams);\n        }\n    }\n}\nconst sortDirectionMap = {\n    ASCENDING: 'ASC',\n    DESCENDING: 'DESC',\n};\nfunction orderByClauseFromSort(sortPredicate = []) {\n    const orderByParts = sortPredicate.map(({ field, sortDirection }) => `\"${String(field)}\" ${sortDirectionMap[sortDirection]}`);\n    // We always sort by _rowid_ last\n    orderByParts.push(`_rowid_ ${sortDirectionMap.ASCENDING}`);\n    return `ORDER BY ${orderByParts.join(', ')}`;\n}\nfunction limitClauseFromPagination(limit, page = 0) {\n    const params = [limit];\n    let clause = 'LIMIT ?';\n    if (page) {\n        const offset = limit * page;\n        params.push(offset);\n        clause += ' OFFSET ?';\n    }\n    return [clause, params];\n}\nfunction queryAllStatement(tableName, predicate, sort, limit, page) {\n    let statement = `SELECT * FROM \"${tableName}\"`;\n    const params = [];\n    if (predicate && predicate.predicates.length) {\n        const [whereClause, whereParams] = whereClauseFromPredicate(predicate);\n        statement += ` ${whereClause}`;\n        params.push(...whereParams);\n    }\n    const orderByClause = orderByClauseFromSort(sort);\n    statement += ` ${orderByClause}`;\n    if (limit) {\n        const [limitClause, limitParams] = limitClauseFromPagination(limit, page);\n        statement += ` ${limitClause}`;\n        params.push(...limitParams);\n    }\n    return [statement, params];\n}\nfunction queryOneStatement(firstOrLast, tableName) {\n    if (firstOrLast === QueryOne.FIRST) {\n        // ORDER BY rowid will no longer work as expected if a customer has\n        // a field by that name in their schema. We may want to enforce it\n        // as a reserved keyword in Codegen\n        return [`SELECT * FROM ${tableName} ORDER BY _rowid_ LIMIT 1`, []];\n    }\n    else {\n        return [`SELECT * FROM ${tableName} ORDER BY _rowid_ DESC LIMIT 1`, []];\n    }\n}\nfunction deleteByIdStatement(id, tableName) {\n    const deleteStatement = `DELETE FROM \"${tableName}\" WHERE \"id\"=?`;\n    return [deleteStatement, [id]];\n}\nfunction deleteByPredicateStatement(tableName, predicate) {\n    let statement = `DELETE FROM \"${tableName}\"`;\n    const params = [];\n    if (predicate && predicate.predicates.length) {\n        const [whereClause, whereParams] = whereClauseFromPredicate(predicate);\n        statement += ` ${whereClause}`;\n        params.push(...whereParams);\n    }\n    return [statement, params];\n}\n\nexport { deleteByIdStatement, deleteByPredicateStatement, generateSchemaStatements, getSQLiteType, implicitAuthFieldsForModel, limitClauseFromPagination, modelCreateTableStatement, modelInsertStatement, modelUpdateStatement, orderByClauseFromSort, queryAllStatement, queryByIdStatement, queryOneStatement, whereClauseFromPredicate, whereConditionFromPredicateObject };\n//# sourceMappingURL=SQLiteUtils.mjs.map\n","import { ConsoleLogger } from '@aws-amplify/core';\nimport { ModelPredicateCreator, OpType, ModelSortPredicateCreator, isPredicateObj, QueryOne, utils } from '@aws-amplify/datastore';\nimport { generateSchemaStatements, queryByIdStatement, modelUpdateStatement, modelInsertStatement, queryAllStatement, queryOneStatement, deleteByPredicateStatement, deleteByIdStatement } from './SQLiteUtils.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst { traverseModel, validatePredicate, isModelConstructor } = utils;\nconst logger = new ConsoleLogger('DataStore');\nclass CommonSQLiteAdapter {\n    constructor(db) {\n        this.db = db;\n    }\n    async setUp(theSchema, namespaceResolver, modelInstanceCreator, getModelConstructorByModelName) {\n        if (!this.initPromise) {\n            this.initPromise = new Promise((_resolve, _reject) => {\n                this.resolve = _resolve;\n                this.reject = _reject;\n            });\n        }\n        else {\n            await this.initPromise;\n            return;\n        }\n        this.schema = theSchema;\n        this.namespaceResolver = namespaceResolver;\n        this.modelInstanceCreator = modelInstanceCreator;\n        this.getModelConstructorByModelName = getModelConstructorByModelName;\n        try {\n            const usesCPKCodegen = Object.values(this.schema.namespaces.user.models).some(model => Object.values(model.fields).some(field => \n            // eslint-disable-next-line no-prototype-builtins\n            field.association?.hasOwnProperty('targetNames')));\n            if (usesCPKCodegen) {\n                logger.error('The SQLite adapter does not support schemas using custom primary key. Set `graphQLTransformer.respectPrimaryKeyAttributesOnConnectionField in `amplify/cli.json` to false to disable custom primary key. To regenerate your API, add or remove an empty newline to your GraphQL schema (to change the computed hash) then run `amplify push`.');\n            }\n            await this.db.init();\n            const statements = generateSchemaStatements(this.schema);\n            await this.db.createSchema(statements);\n            this.resolve();\n        }\n        catch (error) {\n            this.reject(error);\n        }\n    }\n    async clear() {\n        await this.db.clear();\n        this.initPromise = undefined;\n    }\n    async save(model, condition) {\n        const modelConstructor = Object.getPrototypeOf(model)\n            .constructor;\n        const { name: tableName } = modelConstructor;\n        const connectedModels = traverseModel(modelConstructor.name, model, this.schema.namespaces[this.namespaceResolver(modelConstructor)], this.modelInstanceCreator, this.getModelConstructorByModelName);\n        const connectionStoreNames = Object.values(connectedModels).map(({ modelName, item, instance }) => {\n            return { modelName, item, instance };\n        });\n        const [queryStatement, params] = queryByIdStatement(model.id, tableName);\n        const fromDB = await this.db.get(queryStatement, params);\n        if (condition && fromDB) {\n            const predicates = ModelPredicateCreator.getPredicates(condition);\n            const { predicates: predicateObjs, type } = predicates;\n            const isValid = validatePredicate(fromDB, type, predicateObjs);\n            if (!isValid) {\n                const msg = 'Conditional update failed';\n                logger.error(msg, { model: fromDB, condition: predicateObjs });\n                throw new Error(msg);\n            }\n        }\n        const result = [];\n        const saveStatements = new Set();\n        for await (const resItem of connectionStoreNames) {\n            const { modelName, item, instance } = resItem;\n            const { id } = item;\n            const [queryStatementForRestItem, paramsForRestItem] = queryByIdStatement(id, modelName);\n            const fromDBForRestItem = await this.db.get(queryStatementForRestItem, paramsForRestItem);\n            const opType = fromDBForRestItem === undefined ? OpType.INSERT : OpType.UPDATE;\n            const saveStatement = fromDBForRestItem\n                ? modelUpdateStatement(instance, modelName)\n                : modelInsertStatement(instance, modelName);\n            if (id === model.id || opType === OpType.INSERT) {\n                saveStatements.add(saveStatement);\n                result.push([instance, opType]);\n            }\n        }\n        await this.db.batchSave(saveStatements);\n        return result;\n    }\n    async load(namespaceName, srcModelName, records) {\n        const namespace = this.schema.namespaces[namespaceName];\n        const relations = namespace.relationships[srcModelName].relationTypes;\n        const connectionTableNames = relations.map(({ modelName }) => modelName);\n        const modelConstructor = this.getModelConstructorByModelName(namespaceName, srcModelName);\n        if (connectionTableNames.length === 0) {\n            return records.map(record => this.modelInstanceCreator(modelConstructor, record));\n        }\n        // Remove related-model fields. They're all `null` in the database,\n        // and any that happen to be required will result in a false validation\n        // error when DataStore attempts to initialize with `null`.\n        // These fields aren't actually needed here. DataStore will use the FK's\n        // from the schema model.\n        return records.map(record => {\n            for (const r of relations) {\n                delete record[r.fieldName];\n            }\n            return this.modelInstanceCreator(modelConstructor, record);\n        });\n    }\n    async query(modelConstructor, predicate, pagination) {\n        const { name: tableName } = modelConstructor;\n        const namespaceName = this.namespaceResolver(modelConstructor);\n        const predicates = predicate && ModelPredicateCreator.getPredicates(predicate);\n        const sortPredicates = pagination &&\n            pagination.sort &&\n            ModelSortPredicateCreator.getPredicates(pagination.sort);\n        const limit = pagination && pagination.limit;\n        const page = limit && pagination.page;\n        const queryById = predicates && this.idFromPredicate(predicates);\n        const records = (await (async () => {\n            if (queryById) {\n                const record = await this.getById(tableName, queryById);\n                return record ? [record] : [];\n            }\n            const [queryStatement, params] = queryAllStatement(tableName, predicates, sortPredicates, limit, page);\n            return this.db.getAll(queryStatement, params);\n        })());\n        return this.load(namespaceName, modelConstructor.name, records);\n    }\n    async getById(tableName, id) {\n        const [queryStatement, params] = queryByIdStatement(id, tableName);\n        const record = await this.db.get(queryStatement, params);\n        return record;\n    }\n    idFromPredicate(predicates) {\n        const { predicates: predicateObjs } = predicates;\n        const idPredicate = predicateObjs.length === 1 &&\n            predicateObjs.find(p => isPredicateObj(p) && p.field === 'id' && p.operator === 'eq');\n        return idPredicate && idPredicate.operand;\n    }\n    async queryOne(modelConstructor, firstOrLast = QueryOne.FIRST) {\n        const { name: tableName } = modelConstructor;\n        const [queryStatement, params] = queryOneStatement(firstOrLast, tableName);\n        const result = await this.db.get(queryStatement, params);\n        const modelInstance = result && this.modelInstanceCreator(modelConstructor, result);\n        return modelInstance;\n    }\n    // Currently does not cascade\n    // TODO: use FKs in relations and have `ON DELETE CASCADE` set\n    // For Has Many and Has One relations to have SQL handle cascades automatically\n    async delete(modelOrModelConstructor, condition) {\n        if (isModelConstructor(modelOrModelConstructor)) {\n            const modelConstructor = modelOrModelConstructor;\n            const namespaceName = this.namespaceResolver(modelConstructor);\n            const { name: tableName } = modelConstructor;\n            const predicates = condition && ModelPredicateCreator.getPredicates(condition);\n            const queryStatement = queryAllStatement(tableName, predicates);\n            const deleteStatement = deleteByPredicateStatement(tableName, predicates);\n            const models = await this.db.selectAndDelete(queryStatement, deleteStatement);\n            const modelInstances = await this.load(namespaceName, modelConstructor.name, models);\n            return [modelInstances, modelInstances];\n        }\n        else {\n            const model = modelOrModelConstructor;\n            const modelConstructor = Object.getPrototypeOf(model)\n                .constructor;\n            const { name: tableName } = modelConstructor;\n            if (condition) {\n                const [queryStatement, params] = queryByIdStatement(model.id, tableName);\n                const fromDB = await this.db.get(queryStatement, params);\n                if (fromDB === undefined) {\n                    const msg = 'Model instance not found in storage';\n                    logger.warn(msg, { model });\n                    return [[model], []];\n                }\n                const predicates = ModelPredicateCreator.getPredicates(condition);\n                const { predicates: predicateObjs, type } = predicates;\n                const isValid = validatePredicate(fromDB, type, predicateObjs);\n                if (!isValid) {\n                    const msg = 'Conditional update failed';\n                    logger.error(msg, { model: fromDB, condition: predicateObjs });\n                    throw new Error(msg);\n                }\n                const [deleteStatement, deleteParams] = deleteByIdStatement(model.id, tableName);\n                await this.db.save(deleteStatement, deleteParams);\n                return [[model], [model]];\n            }\n            else {\n                const [deleteStatement, params] = deleteByIdStatement(model.id, tableName);\n                await this.db.save(deleteStatement, params);\n                return [[model], [model]];\n            }\n        }\n    }\n    async batchSave(modelConstructor, items) {\n        const { name: tableName } = modelConstructor;\n        const result = [];\n        const itemsToSave = [];\n        // To determine whether an item should result in an insert or update operation\n        // We first need to query the local DB on the item id\n        const queryStatements = new Set();\n        // Deletes don't need to be queried first, because if the item doesn't exist,\n        // the delete operation will be a no-op\n        const deleteStatements = new Set();\n        const saveStatements = new Set();\n        for (const item of items) {\n            const connectedModels = traverseModel(modelConstructor.name, this.modelInstanceCreator(modelConstructor, item), this.schema.namespaces[this.namespaceResolver(modelConstructor)], this.modelInstanceCreator, this.getModelConstructorByModelName);\n            const { id, _deleted } = item;\n            const { instance } = connectedModels.find(({ instance: connectedModelInstance }) => connectedModelInstance.id === id);\n            if (_deleted) {\n                // create the delete statements right away\n                const deleteStatement = deleteByIdStatement(instance.id, tableName);\n                deleteStatements.add(deleteStatement);\n                result.push([item, OpType.DELETE]);\n            }\n            else {\n                // query statements for the saves at first\n                const queryStatement = queryByIdStatement(id, tableName);\n                queryStatements.add(queryStatement);\n                // combination of insert and update items\n                itemsToSave.push(instance);\n            }\n        }\n        // returns the query results for each of the save items\n        const queryResponses = await this.db.batchQuery(queryStatements);\n        queryResponses.forEach((response, idx) => {\n            if (response === undefined) {\n                const insertStatement = modelInsertStatement(itemsToSave[idx], tableName);\n                saveStatements.add(insertStatement);\n                result.push([itemsToSave[idx], OpType.INSERT]);\n            }\n            else {\n                const updateStatement = modelUpdateStatement(itemsToSave[idx], tableName);\n                saveStatements.add(updateStatement);\n                result.push([itemsToSave[idx], OpType.UPDATE]);\n            }\n        });\n        // perform all of the insert/update/delete operations in a single transaction\n        await this.db.batchSave(saveStatements, deleteStatements);\n        return result;\n    }\n}\n\nexport { CommonSQLiteAdapter };\n//# sourceMappingURL=CommonSQLiteAdapter.mjs.map\n","// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst DB_NAME = 'AmplifyDatastore';\n\nexport { DB_NAME };\n//# sourceMappingURL=constants.mjs.map\n","import { ConsoleLogger } from '@aws-amplify/core';\nimport { deleteAsync, documentDirectory } from 'expo-file-system';\nimport { openDatabase } from 'expo-sqlite';\nimport { DB_NAME } from '../common/constants.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst logger = new ConsoleLogger('ExpoSQLiteDatabase');\n/*\n\nNote:\nExpoSQLite transaction error callbacks require returning a boolean value to indicate whether the\nerror was handled or not. Returning a true value indicates the error was handled and does not\nrollback the whole transaction.\n\n*/\nclass ExpoSQLiteDatabase {\n    async init() {\n        // only open database once.\n        if (!this.db) {\n            // As per expo docs version, description and size arguments are ignored,\n            // but are accepted by the function for compatibility with the WebSQL specification.\n            // Hence, we do not need those arguments.\n            this.db = openDatabase(DB_NAME);\n        }\n    }\n    createSchema(statements) {\n        return this.executeStatements(statements);\n    }\n    async clear() {\n        try {\n            logger.debug('Clearing database');\n            await this.closeDB();\n            // delete database is not supported by expo-sqlite.\n            // Database file needs to be deleted using deleteAsync from expo-file-system\n            await deleteAsync(`${documentDirectory}SQLite/${DB_NAME}`);\n            logger.debug('Database cleared');\n        }\n        catch (error) {\n            logger.warn('Error clearing the database.', error);\n            // open database if it was closed earlier and this.db was set to undefined.\n            this.init();\n        }\n    }\n    async get(statement, params) {\n        const results = await this.getAll(statement, params);\n        return results[0];\n    }\n    getAll(statement, params) {\n        return new Promise((resolve, reject) => {\n            this.db.readTransaction(transaction => {\n                transaction.executeSql(statement, params, (_, result) => {\n                    resolve(result.rows._array || []);\n                }, (_, error) => {\n                    reject(error);\n                    logger.warn(error);\n                    return true;\n                });\n            });\n        });\n    }\n    save(statement, params) {\n        return new Promise((resolve, reject) => {\n            this.db.transaction(transaction => {\n                transaction.executeSql(statement, params, () => {\n                    resolve(null);\n                }, (_, error) => {\n                    reject(error);\n                    logger.warn(error);\n                    return true;\n                });\n            });\n        });\n    }\n    batchQuery(queryParameterizedStatements = new Set()) {\n        return new Promise((resolve, reject) => {\n            const resolveTransaction = resolve;\n            const rejectTransaction = reject;\n            this.db.transaction(async (transaction) => {\n                try {\n                    const results = await Promise.all([...queryParameterizedStatements].map(([statement, params]) => new Promise((_resolve, _reject) => {\n                        transaction.executeSql(statement, params, (_, result) => {\n                            _resolve(result.rows._array[0]);\n                        }, (_, error) => {\n                            _reject(error);\n                            logger.warn(error);\n                            return true;\n                        });\n                    })));\n                    resolveTransaction(results);\n                }\n                catch (error) {\n                    rejectTransaction(error);\n                    logger.warn(error);\n                }\n            });\n        });\n    }\n    batchSave(saveParameterizedStatements = new Set(), deleteParameterizedStatements) {\n        return new Promise((resolve, reject) => {\n            const resolveTransaction = resolve;\n            const rejectTransaction = reject;\n            this.db.transaction(async (transaction) => {\n                try {\n                    // await for all sql statements promises to resolve\n                    await Promise.all([...saveParameterizedStatements].map(([statement, params]) => new Promise((_resolve, _reject) => {\n                        transaction.executeSql(statement, params, () => {\n                            _resolve(null);\n                        }, (_, error) => {\n                            _reject(error);\n                            logger.warn(error);\n                            return true;\n                        });\n                    })));\n                    if (deleteParameterizedStatements) {\n                        await Promise.all([...deleteParameterizedStatements].map(([statement, params]) => new Promise((_resolve, _reject) => {\n                            transaction.executeSql(statement, params, () => {\n                                _resolve(null);\n                            }, (_, error) => {\n                                _reject(error);\n                                logger.warn(error);\n                                return true;\n                            });\n                        })));\n                    }\n                    resolveTransaction(null);\n                }\n                catch (error) {\n                    rejectTransaction(error);\n                    logger.warn(error);\n                }\n            });\n        });\n    }\n    selectAndDelete(queryParameterizedStatement, deleteParameterizedStatement) {\n        const [queryStatement, queryParams] = queryParameterizedStatement;\n        const [deleteStatement, deleteParams] = deleteParameterizedStatement;\n        return new Promise((resolve, reject) => {\n            const resolveTransaction = resolve;\n            const rejectTransaction = reject;\n            this.db.transaction(async (transaction) => {\n                try {\n                    const result = await new Promise((_resolve, _reject) => {\n                        transaction.executeSql(queryStatement, queryParams, (_, sqlResult) => {\n                            _resolve(sqlResult.rows._array || []);\n                        }, (_, error) => {\n                            _reject(error);\n                            logger.warn(error);\n                            return true;\n                        });\n                    });\n                    await new Promise((_resolve, _reject) => {\n                        transaction.executeSql(deleteStatement, deleteParams, () => {\n                            _resolve(null);\n                        }, (_, error) => {\n                            _reject(error);\n                            logger.warn(error);\n                            return true;\n                        });\n                    });\n                    resolveTransaction(result);\n                }\n                catch (error) {\n                    rejectTransaction(error);\n                    logger.warn(error);\n                }\n            });\n        });\n    }\n    executeStatements(statements) {\n        return new Promise((resolve, reject) => {\n            const resolveTransaction = resolve;\n            const rejectTransaction = reject;\n            this.db.transaction(async (transaction) => {\n                try {\n                    await Promise.all(statements.map(statement => new Promise((_resolve, _reject) => {\n                        transaction.executeSql(statement, [], () => {\n                            _resolve(null);\n                        }, (_, error) => {\n                            _reject(error);\n                            return true;\n                        });\n                    })));\n                    resolveTransaction(null);\n                }\n                catch (error) {\n                    rejectTransaction(error);\n                    logger.warn(error);\n                }\n            });\n        });\n    }\n    async closeDB() {\n        if (this.db) {\n            logger.debug('Closing Database');\n            // closing database is not supported by expo-sqlite.\n            // Workaround is to access the private db variable and call the close() method.\n            await this.db._db.close();\n            logger.debug('Database closed');\n            this.db = undefined;\n        }\n    }\n}\n\nexport { ExpoSQLiteDatabase as default };\n//# sourceMappingURL=ExpoSQLiteDatabase.mjs.map\n","import { CommonSQLiteAdapter } from '../common/CommonSQLiteAdapter.mjs';\nimport ExpoSQLiteDatabase from './ExpoSQLiteDatabase.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst ExpoSQLiteAdapter = new CommonSQLiteAdapter(new ExpoSQLiteDatabase());\n\nexport { ExpoSQLiteAdapter as default };\n//# sourceMappingURL=ExpoSQLiteAdapter.mjs.map\n"],"names":["root","factory","exports","module","require","define","amd","self","__WEBPACK_EXTERNAL_MODULE__374__","__WEBPACK_EXTERNAL_MODULE__74__","__WEBPACK_EXTERNAL_MODULE__889__","__WEBPACK_EXTERNAL_MODULE__287__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","USER","isNonModelConstructor","isModelConstructor","utils","prepareValueForDML","includes","isObjectType","getPrototypeOf","constructor","Array","isArray","JSON","stringify","implicitAuthFieldsForModel","model","attributes","length","authRules","find","isModelAttributeAuth","properties","rules","filter","rule","ownerField","groupsField","map","authField","values","fields","f","name","modelInsertStatement","tableName","keys","k","join","keysFromModel","paramaterized","valuesFromModel","modelUpdateStatement","entries","v","push","updateSet","id","queryByIdStatement","comparisonOperatorMap","eq","ne","le","lt","ge","gt","logicalOperatorMap","beginsWith","contains","notContains","between","whereClauseFromPredicate","predicate","result","params","recurse","recursedPredicate","recursedResult","recursedParams","isPredicateGroup","type","groupType","predicates","groupPredicates","filterType","isNegation","Error","groupResult","p","isPredicateObj","condition","conditionParams","field","operator","operand","specialNullClause","buildSpecialNullComparison","comparisonOperator","logicalOperator","statement","rightExp","_","whereConditionFromPredicateObject","sortDirectionMap","ASCENDING","DESCENDING","queryAllStatement","sort","limit","page","whereClause","whereParams","sortPredicate","orderByParts","sortDirection","String","orderByClauseFromSort","limitClause","limitParams","clause","offset","limitClauseFromPagination","deleteByIdStatement","traverseModel","validatePredicate","logger","ConsoleLogger","DB_NAME","ExpoSQLiteAdapter","db","this","setUp","theSchema","namespaceResolver","modelInstanceCreator","getModelConstructorByModelName","initPromise","Promise","_resolve","_reject","resolve","reject","schema","namespaces","user","models","some","association","error","init","statements","flatMap","namespaceName","namespace","isUserModel","userModel","implicitAuthFields","reduce","acc","isGraphQLScalarType","columnParam","scalar","getSQLiteType","isRequired","isModelFieldType","isTargetNameAssociation","targetName","required","forEach","modelCreateTableStatement","createSchema","clear","save","modelConstructor","connectedModels","connectionStoreNames","modelName","item","instance","queryStatement","fromDB","ModelPredicateCreator","getPredicates","predicateObjs","msg","saveStatements","Set","resItem","queryStatementForRestItem","paramsForRestItem","fromDBForRestItem","opType","OpType","INSERT","UPDATE","saveStatement","add","batchSave","load","srcModelName","records","relations","relationships","relationTypes","connectionTableNames","record","fieldName","query","pagination","sortPredicates","ModelSortPredicateCreator","queryById","idFromPredicate","getById","getAll","idPredicate","queryOne","firstOrLast","QueryOne","FIRST","queryOneStatement","modelOrModelConstructor","deleteStatement","deleteByPredicateStatement","selectAndDelete","modelInstances","warn","deleteParams","items","itemsToSave","queryStatements","deleteStatements","_deleted","connectedModelInstance","DELETE","batchQuery","response","idx","insertStatement","updateStatement","openDatabase","executeStatements","debug","closeDB","deleteAsync","documentDirectory","readTransaction","transaction","executeSql","rows","_array","queryParameterizedStatements","resolveTransaction","rejectTransaction","async","results","all","saveParameterizedStatements","deleteParameterizedStatements","queryParameterizedStatement","deleteParameterizedStatement","queryParams","sqlResult","_db","close"],"sourceRoot":""}