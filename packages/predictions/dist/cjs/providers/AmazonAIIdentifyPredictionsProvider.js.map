{"version":3,"file":"AmazonAIIdentifyPredictionsProvider.js","sources":["../../../src/providers/AmazonAIIdentifyPredictionsProvider.ts"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AmazonAIIdentifyPredictionsProvider = void 0;\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst core_1 = require(\"@aws-amplify/core\");\nconst utils_1 = require(\"@aws-amplify/core/internals/utils\");\nconst storage_1 = require(\"@aws-amplify/storage\");\nconst client_rekognition_1 = require(\"@aws-sdk/client-rekognition\");\nconst client_textract_1 = require(\"@aws-sdk/client-textract\");\nconst validation_1 = require(\"../errors/types/validation\");\nconst assertValidationError_1 = require(\"../errors/utils/assertValidationError\");\nconst types_1 = require(\"../types\");\nconst IdentifyTextUtils_1 = require(\"./IdentifyTextUtils\");\nconst Utils_1 = require(\"./Utils\");\nconst logger = new core_1.ConsoleLogger('AmazonAIIdentifyPredictionsProvider');\nclass AmazonAIIdentifyPredictionsProvider {\n    getProviderName() {\n        return 'AmazonAIIdentifyPredictionsProvider';\n    }\n    identify(input) {\n        (0, assertValidationError_1.assertValidationError)((0, types_1.isValidIdentifyInput)(input), validation_1.PredictionsValidationErrorCode.InvalidInput);\n        if ((0, types_1.isIdentifyTextInput)(input)) {\n            logger.debug('identifyText');\n            return this.identifyText(input);\n        }\n        else if ((0, types_1.isIdentifyLabelsInput)(input)) {\n            logger.debug('identifyLabels');\n            return this.identifyLabels(input);\n        }\n        else {\n            logger.debug('identifyEntities');\n            return this.identifyEntities(input);\n        }\n    }\n    /**\n     * Verify user input source and converts it into source object readable by Rekognition and Textract.\n     * Note that Rekognition and Textract use the same source interface, so we need not worry about types.\n     * @param {IdentifySource} source - User input source that directs to the object user wants\n     * to identify (storage, file, or bytes).\n     * @return {Promise<Image>} - Promise resolving to the converted source object.\n     */\n    configureSource(source) {\n        return new Promise((resolve, reject) => {\n            if ((0, types_1.isStorageSource)(source)) {\n                const storageConfig = {\n                    accessLevel: source.level,\n                    targetIdentityId: source.identityId,\n                };\n                (0, storage_1.getUrl)({ key: source.key, options: storageConfig })\n                    .then(value => {\n                    const parser = /https:\\/\\/([a-zA-Z0-9%\\-_.]+)\\.s3\\.[A-Za-z0-9%\\-._~]+\\/([a-zA-Z0-9%\\-._~/]+)\\?/;\n                    const parsedURL = value.url.toString().match(parser) ?? '';\n                    if (parsedURL.length < 3)\n                        reject(new Error('Invalid S3 key was given.'));\n                    resolve({\n                        S3Object: {\n                            Bucket: parsedURL[1],\n                            Name: decodeURIComponent(parsedURL[2]),\n                        },\n                    });\n                })\n                    .catch(err => {\n                    reject(err);\n                });\n            }\n            else if ((0, types_1.isFileSource)(source)) {\n                (0, Utils_1.blobToArrayBuffer)(source.file)\n                    .then(buffer => {\n                    resolve({ Bytes: new Uint8Array(buffer) });\n                })\n                    .catch(err => {\n                    reject(err);\n                });\n            }\n            else if ((0, types_1.isIdentifyBytesSource)(source)) {\n                const { bytes } = source;\n                if (bytes instanceof Blob) {\n                    (0, Utils_1.blobToArrayBuffer)(bytes)\n                        .then(buffer => {\n                        resolve({ Bytes: new Uint8Array(buffer) });\n                    })\n                        .catch(err => {\n                        reject(err);\n                    });\n                }\n                if (bytes instanceof ArrayBuffer || bytes instanceof Buffer) {\n                    resolve({ Bytes: new Uint8Array(bytes) });\n                }\n                // everything else can be directly passed to Rekognition / Textract.\n                resolve({ Bytes: bytes });\n            }\n            else {\n                reject(new Error('Input source is not configured correctly.'));\n            }\n        });\n    }\n    /**\n     * Recognize text from real-world images and documents (plain text, forms and tables). Detects text in the input\n     * image and converts it into machine-readable text.\n     * @param {IdentifySource} source - Object containing the source image and feature types to analyze.\n     * @return {Promise<IdentifyTextOutput>} - Promise resolving to object containing identified texts.\n     */\n    async identifyText(input) {\n        const { credentials } = await (0, core_1.fetchAuthSession)();\n        (0, assertValidationError_1.assertValidationError)(!!credentials, validation_1.PredictionsValidationErrorCode.NoCredentials);\n        const { identifyText = {} } = core_1.Amplify.getConfig().Predictions?.identify ?? {};\n        const { region = '', defaults = {} } = identifyText;\n        const { format: configFormat = 'PLAIN' } = defaults;\n        this.rekognitionClient = new client_rekognition_1.RekognitionClient({\n            region,\n            credentials,\n            customUserAgent: _getPredictionsIdentifyAmplifyUserAgent(),\n        });\n        this.textractClient = new client_textract_1.TextractClient({\n            region,\n            credentials,\n            customUserAgent: _getPredictionsIdentifyAmplifyUserAgent(),\n        });\n        const inputDocument = await this.configureSource(input.text?.source);\n        // get default value if format isn't specified in the input.\n        const format = input.text?.format ?? configFormat;\n        const featureTypes = []; // structures we want to analyze (e.g. [TABLES, FORMS]).\n        if (format === 'FORM' || format === 'ALL')\n            featureTypes.push('FORMS');\n        if (format === 'TABLE' || format === 'ALL')\n            featureTypes.push('TABLES');\n        if (featureTypes.length === 0) {\n            /**\n             * Empty featureTypes indicates that we will identify plain text. We will use rekognition (suitable\n             * for everyday images but has 50 word limit) first and see if reaches its word limit. If it does, then\n             * we call textract and use the data that identify more words.\n             */\n            const textractParam = {\n                Document: inputDocument,\n            };\n            const rekognitionParam = {\n                Image: inputDocument,\n            };\n            const detectTextCommand = new client_rekognition_1.DetectTextCommand(rekognitionParam);\n            const rekognitionData = await this.rekognitionClient.send(detectTextCommand);\n            const rekognitionResponse = (0, IdentifyTextUtils_1.categorizeRekognitionBlocks)(rekognitionData.TextDetections);\n            if (rekognitionResponse.text.words.length < 50) {\n                // did not hit the word limit, return the data\n                return rekognitionResponse;\n            }\n            const detectDocumentTextCommand = new client_textract_1.DetectDocumentTextCommand(textractParam);\n            const { Blocks } = await this.textractClient.send(detectDocumentTextCommand);\n            if ((rekognitionData.TextDetections?.length ?? 0) > (Blocks?.length ?? 0)) {\n                return rekognitionResponse;\n            }\n            return (0, IdentifyTextUtils_1.categorizeTextractBlocks)(Blocks);\n        }\n        else {\n            const param = {\n                Document: inputDocument,\n                FeatureTypes: featureTypes,\n            };\n            const analyzeDocumentCommand = new client_textract_1.AnalyzeDocumentCommand(param);\n            const { Blocks } = await this.textractClient.send(analyzeDocumentCommand);\n            return (0, IdentifyTextUtils_1.categorizeTextractBlocks)(Blocks);\n        }\n    }\n    /**\n     * Identify instances of real world entities from an image and if it contains unsafe content.\n     * @param {IdentifyLabelsInput} input - Object containing the source image and entity type to identify.\n     * @return {Promise<IdentifyLabelsOutput>} - Promise resolving to an array of identified entities.\n     */\n    async identifyLabels(input) {\n        const { credentials } = await (0, core_1.fetchAuthSession)();\n        (0, assertValidationError_1.assertValidationError)(!!credentials, validation_1.PredictionsValidationErrorCode.NoCredentials);\n        const { identifyLabels = {} } = core_1.Amplify.getConfig().Predictions?.identify ?? {};\n        const { region = '', defaults = {} } = identifyLabels;\n        const { type = 'LABELS' } = defaults;\n        this.rekognitionClient = new client_rekognition_1.RekognitionClient({\n            region,\n            credentials,\n            customUserAgent: _getPredictionsIdentifyAmplifyUserAgent(),\n        });\n        const inputImage = await this.configureSource(input.labels?.source);\n        const param = { Image: inputImage };\n        const servicePromises = [];\n        // get default argument\n        const entityType = input.labels?.type ?? type;\n        if (entityType === 'LABELS' || entityType === 'ALL') {\n            servicePromises.push(this.detectLabels(param));\n        }\n        if (entityType === 'UNSAFE' || entityType === 'ALL') {\n            servicePromises.push(this.detectModerationLabels(param));\n        }\n        return Promise.all(servicePromises).then(data => {\n            let identifyResult = {};\n            // concatenate resolved promises to a single object\n            data.forEach(val => {\n                identifyResult = { ...identifyResult, ...val };\n            });\n            return identifyResult;\n        });\n    }\n    /**\n     * Calls Rekognition.detectLabels and organizes the returned data.\n     * @param param - parameters as {@link DetectLabelsCommandInput} to be passed onto Rekognition\n     * @return a promise resolving to organized detectLabels response as {@link IdentifyLabelsOutput}.\n     */\n    async detectLabels(param) {\n        const detectLabelsCommand = new client_rekognition_1.DetectLabelsCommand(param);\n        const data = await this.rekognitionClient.send(detectLabelsCommand);\n        if (!data.Labels)\n            return {}; // no image was detected\n        const detectLabelData = data.Labels.map(label => {\n            const boxes = label.Instances?.map(instance => (0, Utils_1.makeCamelCase)(instance.BoundingBox)) || [];\n            return {\n                name: label.Name,\n                boundingBoxes: boxes,\n                metadata: {\n                    confidence: label.Confidence,\n                    parents: (0, Utils_1.makeCamelCaseArray)(label.Parents),\n                },\n            };\n        });\n        return { labels: detectLabelData };\n    }\n    /**\n     * Calls Rekognition.detectModerationLabels and organizes the returned data.\n     * @param param parameter to be passed onto Rekognition as {@link DetectModerationLabelsCommandInput}\n     * @return a promise resolving to organized detectModerationLabels response as {@link IdentifyLabelsOutput}.\n     */\n    async detectModerationLabels(param) {\n        const detectModerationLabelsCommand = new client_rekognition_1.DetectModerationLabelsCommand(param);\n        const data = await this.rekognitionClient.send(detectModerationLabelsCommand);\n        if (data.ModerationLabels?.length !== 0) {\n            return { unsafe: 'YES' };\n        }\n        else {\n            return { unsafe: 'NO' };\n        }\n    }\n    /**\n     * Identify faces within an image that is provided as input, and match faces from a collection\n     * or identify celebrities.\n     * @param input - object of {@link IdentifyEntitiesInput} containing the source image and face match options.\n     * @return a promise resolving to identify results as {@link IdentifyEntitiesOutput}.\n     */\n    async identifyEntities(input) {\n        const { credentials } = await (0, core_1.fetchAuthSession)();\n        (0, assertValidationError_1.assertValidationError)(!!credentials, validation_1.PredictionsValidationErrorCode.NoCredentials);\n        const { identifyEntities = {} } = core_1.Amplify.getConfig().Predictions?.identify ?? {};\n        const { region = '', celebrityDetectionEnabled = false, defaults = {}, } = identifyEntities;\n        const { collectionId: collectionIdConfig = '', maxEntities: maxFacesConfig = 50, } = defaults;\n        // default arguments\n        this.rekognitionClient = new client_rekognition_1.RekognitionClient({\n            region,\n            credentials,\n            customUserAgent: _getPredictionsIdentifyAmplifyUserAgent(),\n        });\n        const inputImage = await this.configureSource(input.entities?.source);\n        const param = { Attributes: ['ALL'], Image: inputImage };\n        if ((0, types_1.isIdentifyCelebrities)(input.entities) &&\n            input.entities.celebrityDetection) {\n            (0, assertValidationError_1.assertValidationError)(celebrityDetectionEnabled, validation_1.PredictionsValidationErrorCode.CelebrityDetectionNotEnabled);\n            const recognizeCelebritiesCommand = new client_rekognition_1.RecognizeCelebritiesCommand(param);\n            const data = await this.rekognitionClient.send(recognizeCelebritiesCommand);\n            const faces = data.CelebrityFaces?.map(celebrity => ({\n                boundingBox: (0, Utils_1.makeCamelCase)(celebrity.Face?.BoundingBox),\n                landmarks: (0, Utils_1.makeCamelCaseArray)(celebrity.Face?.Landmarks),\n                metadata: {\n                    ...(0, Utils_1.makeCamelCase)(celebrity, ['Id', 'Name', 'Urls']),\n                    pose: (0, Utils_1.makeCamelCase)(celebrity.Face?.Pose),\n                },\n            })) ?? [];\n            return { entities: faces };\n        }\n        else if ((0, types_1.isIdentifyFromCollection)(input.entities) &&\n            input.entities.collection) {\n            const { collectionId = collectionIdConfig, maxEntities: maxFaces = maxFacesConfig, } = input.entities;\n            // Concatenate additional parameters\n            const updatedParam = {\n                ...param,\n                CollectionId: collectionId,\n                MaxFaces: maxFaces,\n            };\n            const searchFacesByImageCommand = new client_rekognition_1.SearchFacesByImageCommand(updatedParam);\n            const data = await this.rekognitionClient.send(searchFacesByImageCommand);\n            const faces = data.FaceMatches?.map(match => {\n                const externalImageId = match.Face?.ExternalImageId\n                    ? this.decodeExternalImageId(match.Face.ExternalImageId)\n                    : undefined;\n                return {\n                    boundingBox: (0, Utils_1.makeCamelCase)(match.Face?.BoundingBox),\n                    metadata: {\n                        externalImageId,\n                        similarity: match.Similarity,\n                    },\n                };\n            }) ?? [];\n            return { entities: faces };\n        }\n        else {\n            const detectFacesCommand = new client_rekognition_1.DetectFacesCommand(param);\n            const data = await this.rekognitionClient.send(detectFacesCommand);\n            const faces = data.FaceDetails?.map(detail => {\n                // face attributes keys we want to extract from Rekognition's response\n                const attributeKeys = [\n                    'Smile',\n                    'Eyeglasses',\n                    'Sunglasses',\n                    'Gender',\n                    'Beard',\n                    'Mustache',\n                    'EyesOpen',\n                    'MouthOpen',\n                ];\n                const faceAttributes = (0, Utils_1.makeCamelCase)(detail, attributeKeys);\n                faceAttributes.emotions = detail.Emotions?.map(emotion => emotion.Type);\n                return {\n                    boundingBox: (0, Utils_1.makeCamelCase)(detail.BoundingBox),\n                    landmarks: (0, Utils_1.makeCamelCaseArray)(detail.Landmarks),\n                    ageRange: (0, Utils_1.makeCamelCase)(detail.AgeRange),\n                    attributes: faceAttributes,\n                    metadata: {\n                        confidence: detail.Confidence,\n                        pose: (0, Utils_1.makeCamelCase)(detail.Pose),\n                    },\n                };\n            }) ?? [];\n            return { entities: faces };\n        }\n    }\n    decodeExternalImageId(externalImageId) {\n        return ('' + externalImageId).replace(/::/g, '/');\n    }\n}\nexports.AmazonAIIdentifyPredictionsProvider = AmazonAIIdentifyPredictionsProvider;\nfunction _getPredictionsIdentifyAmplifyUserAgent() {\n    return (0, utils_1.getAmplifyUserAgentObject)({\n        category: utils_1.Category.Predictions,\n        action: utils_1.PredictionsAction.Identify,\n    });\n}\n"],"names":[],"mappings":"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"}